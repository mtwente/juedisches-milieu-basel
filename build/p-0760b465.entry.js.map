{"version":3,"names":["appRootCss","AppRoot","render","h","useHash","ref","e","routerProvider","ionRouterElement","from","to","url","component","appPages","map","p","beforeEnter","state","key","redirect","style","display","href","appCss","App","componentDidLoad","rIC","async","isHybrid","isPlatform","window","config","getBoolean","import","then","module","startTapClick","startStatusTap","needInputShims","platform","startInputShims","hardwareBackButtonModule","startHardwareBackButton","blockHardwareBackButton","startKeyboardAssist","this","focusVisible","startFocusVisible","setFocus","elements","mode","getIonMode","Host","class","needsShimsIOS","isAndroidMobileWeb","callback","requestIdleCallback","setTimeout","Route","constructor","hostRef","undefined","componentProps","beforeLeave","onUpdate","newValue","ionRouteDataChanged","emit","onComponentProps","oldValue","keys1","Object","keys","keys2","length","connectedCallback","RouteRedirect","propDidChange","ionRouteRedirectChanged","ROUTER_INTENT_NONE","ROUTER_INTENT_FORWARD","ROUTER_INTENT_BACK","generatePath","segments","path","filter","s","join","generateUrl","queryString","writeSegments","history","root","direction","parsePath","pushState","replaceState","chainToSegments","chain","route","segment","param","params","slice","push","removePrefix","prefix","i","readSegments","loc","pathname","hash","qsStart","indexOf","substring","split","trim","printRoutes","routes","console","group","forEach","r","ids","id","debug","groupEnd","printRedirects","redirects","writeNavState","index","changed","animation","outlet","searchNavNode","Promise","resolve","componentOnReady","result","setRouteId","element","markVisible","error","readNavState","node","getRouteId","waitUntilNavNode","document","body","addEventListener","once","OUTLET_SELECTOR","matches","querySelector","matchesRedirect","expected","findRouteRedirect","find","matchesIDs","len","Math","min","score","routeId","routeChain","toLowerCase","routeIdParams","pathWithParams","j","matchesSegments","inputSegments","RouterSegments","matchesDefault","allparams","chainSegments","data","next","mergeParams","a","b","assign","findChainForIDs","chains","match","maxMatches","_a","findChainForSegments","bestScore","matchedChain","computePriority","level","pow","shift","readProp","el","prop","hasAttribute","getAttribute","readRedirects","Array","children","tagName","readRoutes","flattenRouterTree","readRouteNodes","nodes","flattenNode","child","Router","previousPath","busy","lastState","componentWillLoad","canProceed","runGuards","getSegments","setSegments","writeNavStateRoot","onRoutesChanged","debounce","onRedirectChanged","bind","onPopState","historyDirection","onBackButton","ev","detail","register","processNextHandler","back","canTransition","startsWith","currentPath","URL","search","parsedPath","waitPromise","printDebug","navChanged","warn","safeWriteNavState","win","title","location","redirectFrom","toSegments","unlock","lock","fromChain","beforeLeaveHook","canLeave","toChain","beforeEnterHook","routeEvent","routeChangeEvent","ionRouteWillChange","ionRouteDidChange","redirectFromSegments","redirectedFrom","routeOutletCss","RouterOutlet","gestureOrAnimationInProgress","delegate","animated","swipeHandler","swipeHandlerChanged","gesture","enable","onStart","createSwipeBackGesture","canStart","step","ani","progressStep","shouldComplete","dur","onFinish","onEnd","oneTimeCallback","newStepValue","easing","getTimeGivenProgression","progressEnd","ionNavWillLoad","disconnectedCallback","destroy","commit","enteringEl","leavingEl","opts","transition","setRoot","duration","animationBuilder","activeEl","active","activeParams","activeComponent","shallowEqualStringMap","attachComponent","detachComponent","ionNavWillChange","get","baseEl","deepWait","hasLazyBuild","progressCallback","progressAnimation","ionNavDidChange"],"sources":["src/components/app-root/app-root.css?tag=app-root","src/components/app-root/app-root.tsx","node_modules/@ionic/core/dist/collection/components/app/app.css?tag=ion-app","node_modules/@ionic/core/dist/collection/components/app/app.js","node_modules/@ionic/core/dist/collection/components/route/route.js","node_modules/@ionic/core/dist/collection/components/route-redirect/route-redirect.js","node_modules/@ionic/core/dist/collection/components/router/utils/constants.js","node_modules/@ionic/core/dist/collection/components/router/utils/path.js","node_modules/@ionic/core/dist/collection/components/router/utils/debug.js","node_modules/@ionic/core/dist/collection/components/router/utils/dom.js","node_modules/@ionic/core/dist/collection/components/router/utils/matching.js","node_modules/@ionic/core/dist/collection/components/router/utils/parser.js","node_modules/@ionic/core/dist/collection/components/router/router.js","node_modules/@ionic/core/dist/collection/components/router-outlet/route-outlet.css?tag=ion-router-outlet&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/router-outlet/route-outlet.js"],"sourcesContent":[null,"import { Component, h } from '@stencil/core';\nimport routerProvider from '../../global/router-provider';\nimport { appPages } from '../../global/appPages';\nimport { state } from '../../global/store';\nimport { NavigationHookResult } from '@ionic/core/dist/types/components/route/route-interface';\n\n@Component({\n  tag: 'app-root',\n  styleUrl: 'app-root.css',\n  // shadow: true,\n})\nexport class AppRoot {\n  render() {\n    return (\n      <ion-app>\n        <ion-router useHash={false} ref={e => (routerProvider.ionRouterElement = e)}>\n          <ion-route-redirect from=\"/\" to=\"/intro\"></ion-route-redirect>\n          <ion-route url=\"/intro\" component=\"page-intro\"></ion-route>\n          <ion-route url=\"/puzzle\" component=\"page-puzzle\"></ion-route>\n          {appPages.map(p => (\n            <ion-route\n              url={p.url}\n              component={p.component}\n              beforeEnter={() => {\n                if (state[p.key] === 'locked') {\n                  const redirect: NavigationHookResult = {\n                    redirect: '/puzzle',\n                  };\n                  return redirect;\n                }\n                return true;\n              }}\n            ></ion-route>\n          ))}\n          <ion-route url=\"/about-us\" component=\"page-about-us\"></ion-route>\n          <ion-route url=\"/belohnung\" component=\"page-gratification\"></ion-route>\n        </ion-router>\n\n        <ion-router-outlet></ion-router-outlet>\n\n        <a style={{ display: 'none' }} href=\"/intro\"></a>\n        <a style={{ display: 'none' }} href=\"/puzzle\"></a>\n      </ion-app>\n    );\n  }\n}\n","html.plt-mobile ion-app {\n  user-select: none;\n}\n\n/**\n * This works around a WebKit issue\n * where user-select: none was causing\n * contenteditable to not be selectable,\n * even though inputs and textareas are selectable.\n */\nhtml.plt-mobile ion-app [contenteditable] {\n  user-select: text;\n}\n\nion-app.force-statusbar-padding {\n  --ion-safe-area-top: 20px;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Build, Host, h } from '@stencil/core';\nimport { isPlatform } from \"../../utils/platform\";\nimport { config } from '../../global/config';\nimport { getIonMode } from '../../global/ionic-global';\nexport class App {\n  componentDidLoad() {\n    if (Build.isBrowser) {\n      rIC(async () => {\n        const isHybrid = isPlatform(window, 'hybrid');\n        if (!config.getBoolean('_testing')) {\n          import('../../utils/tap-click').then((module) => module.startTapClick(config));\n        }\n        if (config.getBoolean('statusTap', isHybrid)) {\n          import('../../utils/status-tap').then((module) => module.startStatusTap());\n        }\n        if (config.getBoolean('inputShims', needInputShims())) {\n          /**\n           * needInputShims() ensures that only iOS and Android\n           * platforms proceed into this block.\n           */\n          const platform = isPlatform(window, 'ios') ? 'ios' : 'android';\n          import('../../utils/input-shims/input-shims').then((module) => module.startInputShims(config, platform));\n        }\n        const hardwareBackButtonModule = await import('../../utils/hardware-back-button');\n        if (config.getBoolean('hardwareBackButton', isHybrid)) {\n          hardwareBackButtonModule.startHardwareBackButton();\n        }\n        else {\n          hardwareBackButtonModule.blockHardwareBackButton();\n        }\n        if (typeof window !== 'undefined') {\n          import('../../utils/keyboard/keyboard').then((module) => module.startKeyboardAssist(window));\n        }\n        import('../../utils/focus-visible').then((module) => (this.focusVisible = module.startFocusVisible()));\n      });\n    }\n  }\n  /**\n   * @internal\n   * Used to set focus on an element that uses `ion-focusable`.\n   * Do not use this if focusing the element as a result of a keyboard\n   * event as the focus utility should handle this for us. This method\n   * should be used when we want to programmatically focus an element as\n   * a result of another user action. (Ex: We focus the first element\n   * inside of a popover when the user presents it, but the popover is not always\n   * presented as a result of keyboard action.)\n   */\n  async setFocus(elements) {\n    if (this.focusVisible) {\n      this.focusVisible.setFocus(elements);\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'ion-page': true,\n        'force-statusbar-padding': config.getBoolean('_forceStatusbarPadding'),\n      } }));\n  }\n  static get is() { return \"ion-app\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"app.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"app.css\"]\n    };\n  }\n  static get methods() {\n    return {\n      \"setFocus\": {\n        \"complexType\": {\n          \"signature\": \"(elements: HTMLElement[]) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": \"Used to set focus on an element that uses `ion-focusable`.\\nDo not use this if focusing the element as a result of a keyboard\\nevent as the focus utility should handle this for us. This method\\nshould be used when we want to programmatically focus an element as\\na result of another user action. (Ex: We focus the first element\\ninside of a popover when the user presents it, but the popover is not always\\npresented as a result of keyboard action.)\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n}\nconst needInputShims = () => {\n  /**\n   * iOS always needs input shims\n   */\n  const needsShimsIOS = isPlatform(window, 'ios') && isPlatform(window, 'mobile');\n  if (needsShimsIOS) {\n    return true;\n  }\n  /**\n   * Android only needs input shims when running\n   * in the browser and only if the browser is using the\n   * new Chrome 108+ resize behavior: https://developer.chrome.com/blog/viewport-resize-behavior/\n   */\n  const isAndroidMobileWeb = isPlatform(window, 'android') && isPlatform(window, 'mobileweb');\n  if (isAndroidMobileWeb) {\n    return true;\n  }\n  return false;\n};\nconst rIC = (callback) => {\n  if ('requestIdleCallback' in window) {\n    window.requestIdleCallback(callback);\n  }\n  else {\n    setTimeout(callback, 32);\n  }\n};\n","// TODO(FW-2832): types\nexport class Route {\n  constructor() {\n    this.url = '';\n    this.component = undefined;\n    this.componentProps = undefined;\n    this.beforeLeave = undefined;\n    this.beforeEnter = undefined;\n  }\n  onUpdate(newValue) {\n    this.ionRouteDataChanged.emit(newValue);\n  }\n  onComponentProps(newValue, oldValue) {\n    if (newValue === oldValue) {\n      return;\n    }\n    const keys1 = newValue ? Object.keys(newValue) : [];\n    const keys2 = oldValue ? Object.keys(oldValue) : [];\n    if (keys1.length !== keys2.length) {\n      this.onUpdate(newValue);\n      return;\n    }\n    for (const key of keys1) {\n      if (newValue[key] !== oldValue[key]) {\n        this.onUpdate(newValue);\n        return;\n      }\n    }\n  }\n  connectedCallback() {\n    this.ionRouteDataChanged.emit();\n  }\n  static get is() { return \"ion-route\"; }\n  static get properties() {\n    return {\n      \"url\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Relative path that needs to match in order for this route to apply.\\n\\nAccepts paths similar to expressjs so that you can define parameters\\nin the url /foo/:bar where bar would be available in incoming props.\"\n        },\n        \"attribute\": \"url\",\n        \"reflect\": false,\n        \"defaultValue\": \"''\"\n      },\n      \"component\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": true,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Name of the component to load/select in the navigation outlet (`ion-tabs`, `ion-nav`)\\nwhen the route matches.\\n\\nThe value of this property is not always the tagname of the component to load,\\nin `ion-tabs` it actually refers to the name of the `ion-tab` to select.\"\n        },\n        \"attribute\": \"component\",\n        \"reflect\": false\n      },\n      \"componentProps\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"{ [key: string]: any }\",\n          \"resolved\": \"undefined | { [key: string]: any; }\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A key value `{ 'red': true, 'blue': 'white'}` containing props that should be passed\\nto the defined component when rendered.\"\n        }\n      },\n      \"beforeLeave\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"NavigationHookCallback\",\n          \"resolved\": \"(() => NavigationHookResult | Promise<NavigationHookResult>) | undefined\",\n          \"references\": {\n            \"NavigationHookCallback\": {\n              \"location\": \"import\",\n              \"path\": \"./route-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A navigation hook that is fired when the route tries to leave.\\nReturning `true` allows the navigation to proceed, while returning\\n`false` causes it to be cancelled. Returning a `NavigationHookOptions`\\nobject causes the router to redirect to the path specified.\"\n        }\n      },\n      \"beforeEnter\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"NavigationHookCallback\",\n          \"resolved\": \"(() => NavigationHookResult | Promise<NavigationHookResult>) | undefined\",\n          \"references\": {\n            \"NavigationHookCallback\": {\n              \"location\": \"import\",\n              \"path\": \"./route-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A navigation hook that is fired when the route tries to enter.\\nReturning `true` allows the navigation to proceed, while returning\\n`false` causes it to be cancelled. Returning a `NavigationHookOptions`\\nobject causes the router to redirect to the path specified.\"\n        }\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionRouteDataChanged\",\n        \"name\": \"ionRouteDataChanged\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Used internally by `ion-router` to know when this route did change.\"\n        },\n        \"complexType\": {\n          \"original\": \"any\",\n          \"resolved\": \"any\",\n          \"references\": {}\n        }\n      }];\n  }\n  static get watchers() {\n    return [{\n        \"propName\": \"url\",\n        \"methodName\": \"onUpdate\"\n      }, {\n        \"propName\": \"component\",\n        \"methodName\": \"onUpdate\"\n      }, {\n        \"propName\": \"componentProps\",\n        \"methodName\": \"onComponentProps\"\n      }];\n  }\n}\n","export class RouteRedirect {\n  constructor() {\n    this.from = undefined;\n    this.to = undefined;\n  }\n  propDidChange() {\n    this.ionRouteRedirectChanged.emit();\n  }\n  connectedCallback() {\n    this.ionRouteRedirectChanged.emit();\n  }\n  static get is() { return \"ion-route-redirect\"; }\n  static get properties() {\n    return {\n      \"from\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": true,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A redirect route, redirects \\\"from\\\" a URL \\\"to\\\" another URL. This property is that \\\"from\\\" URL.\\nIt needs to be an exact match of the navigated URL in order to apply.\\n\\nThe path specified in this value is always an absolute path, even if the initial `/` slash\\nis not specified.\"\n        },\n        \"attribute\": \"from\",\n        \"reflect\": false\n      },\n      \"to\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string | undefined | null\",\n          \"resolved\": \"null | string | undefined\",\n          \"references\": {}\n        },\n        \"required\": true,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A redirect route, redirects \\\"from\\\" a URL \\\"to\\\" another URL. This property is that \\\"to\\\" URL.\\nWhen the defined `ion-route-redirect` rule matches, the router will redirect to the path\\nspecified in this property.\\n\\nThe value of this property is always an absolute path inside the scope of routes defined in\\n`ion-router` it can't be used with another router or to perform a redirection to a different domain.\\n\\nNote that this is a virtual redirect, it will not cause a real browser refresh, again, it's\\na redirect inside the context of ion-router.\\n\\nWhen this property is not specified or his value is `undefined` the whole redirect route is noop,\\neven if the \\\"from\\\" value matches.\"\n        },\n        \"attribute\": \"to\",\n        \"reflect\": false\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionRouteRedirectChanged\",\n        \"name\": \"ionRouteRedirectChanged\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Internal event that fires when any value of this rule is added/removed from the DOM,\\nor any of his public properties changes.\\n\\n`ion-router` captures this event in order to update his internal registry of router rules.\"\n        },\n        \"complexType\": {\n          \"original\": \"any\",\n          \"resolved\": \"any\",\n          \"references\": {}\n        }\n      }];\n  }\n  static get watchers() {\n    return [{\n        \"propName\": \"from\",\n        \"methodName\": \"propDidChange\"\n      }, {\n        \"propName\": \"to\",\n        \"methodName\": \"propDidChange\"\n      }];\n  }\n}\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport const ROUTER_INTENT_NONE = 'root';\nexport const ROUTER_INTENT_FORWARD = 'forward';\nexport const ROUTER_INTENT_BACK = 'back';\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { ROUTER_INTENT_FORWARD } from './constants';\n/** Join the non empty segments with \"/\". */\nexport const generatePath = (segments) => {\n  const path = segments.filter((s) => s.length > 0).join('/');\n  return '/' + path;\n};\nconst generateUrl = (segments, useHash, queryString) => {\n  let url = generatePath(segments);\n  if (useHash) {\n    url = '#' + url;\n  }\n  if (queryString !== undefined) {\n    url += '?' + queryString;\n  }\n  return url;\n};\nexport const writeSegments = (history, root, useHash, segments, direction, state, queryString) => {\n  const url = generateUrl([...parsePath(root).segments, ...segments], useHash, queryString);\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  }\n  else {\n    history.replaceState(state, '', url);\n  }\n};\n/**\n * Transforms a chain to a list of segments.\n *\n * Notes:\n * - parameter segments of the form :param are replaced with their value,\n * - null is returned when a value is missing for any parameter segment.\n */\nexport const chainToSegments = (chain) => {\n  const segments = [];\n  for (const route of chain) {\n    for (const segment of route.segments) {\n      if (segment[0] === ':') {\n        const param = route.params && route.params[segment.slice(1)];\n        if (!param) {\n          return null;\n        }\n        segments.push(param);\n      }\n      else if (segment !== '') {\n        segments.push(segment);\n      }\n    }\n  }\n  return segments;\n};\n/**\n * Removes the prefix segments from the path segments.\n *\n * Return:\n * - null when the path segments do not start with the passed prefix,\n * - the path segments after the prefix otherwise.\n */\nconst removePrefix = (prefix, segments) => {\n  if (prefix.length > segments.length) {\n    return null;\n  }\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return segments;\n  }\n  for (let i = 0; i < prefix.length; i++) {\n    if (prefix[i] !== segments[i]) {\n      return null;\n    }\n  }\n  if (segments.length === prefix.length) {\n    return [''];\n  }\n  return segments.slice(prefix.length);\n};\nexport const readSegments = (loc, root, useHash) => {\n  const prefix = parsePath(root).segments;\n  const pathname = useHash ? loc.hash.slice(1) : loc.pathname;\n  const segments = parsePath(pathname).segments;\n  return removePrefix(prefix, segments);\n};\n/**\n * Parses the path to:\n * - segments an array of '/' separated parts,\n * - queryString (undefined when no query string).\n */\nexport const parsePath = (path) => {\n  let segments = [''];\n  let queryString;\n  if (path != null) {\n    const qsStart = path.indexOf('?');\n    if (qsStart > -1) {\n      queryString = path.substring(qsStart + 1);\n      path = path.substring(0, qsStart);\n    }\n    segments = path\n      .split('/')\n      .map((s) => s.trim())\n      .filter((s) => s.length > 0);\n    if (segments.length === 0) {\n      segments = [''];\n    }\n  }\n  return { segments, queryString };\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { generatePath } from './path';\nexport const printRoutes = (routes) => {\n  console.group(`[ion-core] ROUTES[${routes.length}]`);\n  for (const chain of routes) {\n    const segments = [];\n    chain.forEach((r) => segments.push(...r.segments));\n    const ids = chain.map((r) => r.id);\n    console.debug(`%c ${generatePath(segments)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\n  }\n  console.groupEnd();\n};\nexport const printRedirects = (redirects) => {\n  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\n  for (const redirect of redirects) {\n    if (redirect.to) {\n      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to.segments)}`, 'font-weight: bold');\n    }\n  }\n  console.groupEnd();\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { componentOnReady } from \"../../../utils/helpers\";\nimport { ROUTER_INTENT_NONE } from './constants';\n/**\n * Activates the passed route chain.\n *\n * There must be exactly one outlet per route entry in the chain.\n *\n * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.\n * setRouteId will create or select the view in the outlet.\n */\nexport const writeNavState = async (root, chain, direction, index, changed = false, animation) => {\n  try {\n    // find next navigation outlet in the DOM\n    const outlet = searchNavNode(root);\n    // make sure we can continue interacting the DOM, otherwise abort\n    if (index >= chain.length || !outlet) {\n      return changed;\n    }\n    await new Promise((resolve) => componentOnReady(outlet, resolve));\n    const route = chain[index];\n    const result = await outlet.setRouteId(route.id, route.params, direction, animation);\n    // if the outlet changed the page, reset navigation to neutral (no direction)\n    // this means nested outlets will not animate\n    if (result.changed) {\n      direction = ROUTER_INTENT_NONE;\n      changed = true;\n    }\n    // recursively set nested outlets\n    changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);\n    // once all nested outlets are visible let's make the parent visible too,\n    // using markVisible prevents flickering\n    if (result.markVisible) {\n      await result.markVisible();\n    }\n    return changed;\n  }\n  catch (e) {\n    console.error(e);\n    return false;\n  }\n};\n/**\n * Recursively walks the outlet in the DOM.\n *\n * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.\n */\nexport const readNavState = async (root) => {\n  const ids = [];\n  let outlet;\n  let node = root;\n  // eslint-disable-next-line no-cond-assign\n  while ((outlet = searchNavNode(node))) {\n    const id = await outlet.getRouteId();\n    if (id) {\n      node = id.element;\n      id.element = undefined;\n      ids.push(id);\n    }\n    else {\n      break;\n    }\n  }\n  return { ids, outlet };\n};\nexport const waitUntilNavNode = () => {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n  return new Promise((resolve) => {\n    window.addEventListener('ionNavWillLoad', () => resolve(), { once: true });\n  });\n};\n/** Selector for all the outlets supported by the router. */\nconst OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nconst searchNavNode = (root) => {\n  if (!root) {\n    return undefined;\n  }\n  if (root.matches(OUTLET_SELECTOR)) {\n    return root;\n  }\n  const outlet = root.querySelector(OUTLET_SELECTOR);\n  return outlet !== null && outlet !== void 0 ? outlet : undefined;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Returns whether the given redirect matches the given path segments.\n *\n * A redirect matches when the segments of the path and redirect.from are equal.\n * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.\n * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].\n */\nexport const matchesRedirect = (segments, redirect) => {\n  const { from, to } = redirect;\n  if (to === undefined) {\n    return false;\n  }\n  if (from.length > segments.length) {\n    return false;\n  }\n  for (let i = 0; i < from.length; i++) {\n    const expected = from[i];\n    if (expected === '*') {\n      return true;\n    }\n    if (expected !== segments[i]) {\n      return false;\n    }\n  }\n  return from.length === segments.length;\n};\n/** Returns the first redirect matching the path segments or undefined when no match found. */\nexport const findRouteRedirect = (segments, redirects) => {\n  return redirects.find((redirect) => matchesRedirect(segments, redirect));\n};\nexport const matchesIDs = (ids, chain) => {\n  const len = Math.min(ids.length, chain.length);\n  let score = 0;\n  for (let i = 0; i < len; i++) {\n    const routeId = ids[i];\n    const routeChain = chain[i];\n    // Skip results where the route id does not match the chain at the same index\n    if (routeId.id.toLowerCase() !== routeChain.id) {\n      break;\n    }\n    if (routeId.params) {\n      const routeIdParams = Object.keys(routeId.params);\n      // Only compare routes with the chain that have the same number of parameters.\n      if (routeIdParams.length === routeChain.segments.length) {\n        // Maps the route's params into a path based on the path variable names,\n        // to compare against the route chain format.\n        //\n        // Before:\n        // ```ts\n        // {\n        //  params: {\n        //    s1: 'a',\n        //    s2: 'b'\n        //  }\n        // }\n        // ```\n        //\n        // After:\n        // ```ts\n        // [':s1',':s2']\n        // ```\n        //\n        const pathWithParams = routeIdParams.map((key) => `:${key}`);\n        for (let j = 0; j < pathWithParams.length; j++) {\n          // Skip results where the path variable is not a match\n          if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {\n            break;\n          }\n          // Weight path matches for the same index higher.\n          score++;\n        }\n      }\n    }\n    // Weight id matches\n    score++;\n  }\n  return score;\n};\n/**\n * Matches the segments against the chain.\n *\n * Returns:\n * - null when there is no match,\n * - a chain with the params properties updated with the parameter segments on match.\n */\nexport const matchesSegments = (segments, chain) => {\n  const inputSegments = new RouterSegments(segments);\n  let matchesDefault = false;\n  let allparams;\n  for (let i = 0; i < chain.length; i++) {\n    const chainSegments = chain[i].segments;\n    if (chainSegments[0] === '') {\n      matchesDefault = true;\n    }\n    else {\n      for (const segment of chainSegments) {\n        const data = inputSegments.next();\n        // data param\n        if (segment[0] === ':') {\n          if (data === '') {\n            return null;\n          }\n          allparams = allparams || [];\n          const params = allparams[i] || (allparams[i] = {});\n          params[segment.slice(1)] = data;\n        }\n        else if (data !== segment) {\n          return null;\n        }\n      }\n      matchesDefault = false;\n    }\n  }\n  const matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;\n  if (!matches) {\n    return null;\n  }\n  if (allparams) {\n    return chain.map((route, i) => ({\n      id: route.id,\n      segments: route.segments,\n      params: mergeParams(route.params, allparams[i]),\n      beforeEnter: route.beforeEnter,\n      beforeLeave: route.beforeLeave,\n    }));\n  }\n  return chain;\n};\n/**\n * Merges the route parameter objects.\n * Returns undefined when both parameters are undefined.\n */\nexport const mergeParams = (a, b) => {\n  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;\n};\n/**\n * Finds the best match for the ids in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the RouteIDs.\n * That is they contain both the componentProps of the <ion-route> and the parameter segment.\n */\nexport const findChainForIDs = (ids, chains) => {\n  let match = null;\n  let maxMatches = 0;\n  for (const chain of chains) {\n    const score = matchesIDs(ids, chain);\n    if (score > maxMatches) {\n      match = chain;\n      maxMatches = score;\n    }\n  }\n  if (match) {\n    return match.map((route, i) => {\n      var _a;\n      return ({\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params),\n      });\n    });\n  }\n  return null;\n};\n/**\n * Finds the best match for the segments in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the segments.\n * That is they contain both the componentProps of the <ion-route> and the parameter segments.\n */\nexport const findChainForSegments = (segments, chains) => {\n  let match = null;\n  let bestScore = 0;\n  for (const chain of chains) {\n    const matchedChain = matchesSegments(segments, chain);\n    if (matchedChain !== null) {\n      const score = computePriority(matchedChain);\n      if (score > bestScore) {\n        bestScore = score;\n        match = matchedChain;\n      }\n    }\n  }\n  return match;\n};\n/**\n * Computes the priority of a chain.\n *\n * Parameter segments are given a lower priority over fixed segments.\n *\n * Considering the following 2 chains matching the path /path/to/page:\n * - /path/to/:where\n * - /path/to/page\n *\n * The second one will be given a higher priority because \"page\" is a fixed segment (vs \":where\", a parameter segment).\n */\nexport const computePriority = (chain) => {\n  let score = 1;\n  let level = 1;\n  for (const route of chain) {\n    for (const segment of route.segments) {\n      if (segment[0] === ':') {\n        score += Math.pow(1, level);\n      }\n      else if (segment !== '') {\n        score += Math.pow(2, level);\n      }\n      level++;\n    }\n  }\n  return score;\n};\nexport class RouterSegments {\n  constructor(segments) {\n    this.segments = segments.slice();\n  }\n  next() {\n    if (this.segments.length > 0) {\n      return this.segments.shift();\n    }\n    return '';\n  }\n}\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { parsePath } from './path';\nconst readProp = (el, prop) => {\n  if (prop in el) {\n    return el[prop];\n  }\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n  return null;\n};\n/**\n * Extracts the redirects (that is <ion-route-redirect> elements inside the root).\n *\n * The redirects are returned as a list of RouteRedirect.\n */\nexport const readRedirects = (root) => {\n  return Array.from(root.children)\n    .filter((el) => el.tagName === 'ION-ROUTE-REDIRECT')\n    .map((el) => {\n    const to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')).segments,\n      to: to == null ? undefined : parsePath(to),\n    };\n  });\n};\n/**\n * Extracts all the routes (that is <ion-route> elements inside the root).\n *\n * The routes are returned as a list of chains - the flattened tree.\n */\nexport const readRoutes = (root) => {\n  return flattenRouterTree(readRouteNodes(root));\n};\n/**\n * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.\n *\n * Note: routes without a component are ignored together with their children.\n */\nexport const readRouteNodes = (node) => {\n  return Array.from(node.children)\n    .filter((el) => el.tagName === 'ION-ROUTE' && el.component)\n    .map((el) => {\n    const component = readProp(el, 'component');\n    return {\n      segments: parsePath(readProp(el, 'url')).segments,\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      beforeLeave: el.beforeLeave,\n      beforeEnter: el.beforeEnter,\n      children: readRouteNodes(el),\n    };\n  });\n};\n/**\n * Flattens a RouterTree in a list of chains.\n *\n * Each chain represents a path from the root node to a terminal node.\n */\nexport const flattenRouterTree = (nodes) => {\n  const chains = [];\n  for (const node of nodes) {\n    flattenNode([], chains, node);\n  }\n  return chains;\n};\n/** Flattens a route node recursively and push each branch to the chains list. */\nconst flattenNode = (chain, chains, node) => {\n  chain = [\n    ...chain,\n    {\n      id: node.id,\n      segments: node.segments,\n      params: node.params,\n      beforeLeave: node.beforeLeave,\n      beforeEnter: node.beforeEnter,\n    },\n  ];\n  if (node.children.length === 0) {\n    chains.push(chain);\n    return;\n  }\n  for (const child of node.children) {\n    flattenNode(chain, chains, child);\n  }\n};\n","import { debounce } from \"../../utils/helpers\";\nimport { ROUTER_INTENT_BACK, ROUTER_INTENT_FORWARD, ROUTER_INTENT_NONE } from './utils/constants';\nimport { printRedirects, printRoutes } from './utils/debug';\nimport { readNavState, waitUntilNavNode, writeNavState } from './utils/dom';\nimport { findChainForIDs, findChainForSegments, findRouteRedirect } from './utils/matching';\nimport { readRedirects, readRoutes } from './utils/parser';\nimport { chainToSegments, generatePath, parsePath, readSegments, writeSegments } from './utils/path';\nexport class Router {\n  constructor() {\n    this.previousPath = null;\n    this.busy = false;\n    this.state = 0;\n    this.lastState = 0;\n    this.root = '/';\n    this.useHash = true;\n  }\n  async componentWillLoad() {\n    await waitUntilNavNode();\n    const canProceed = await this.runGuards(this.getSegments());\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        const { redirect } = canProceed;\n        const path = parsePath(redirect);\n        this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);\n        await this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);\n      }\n    }\n    else {\n      await this.onRoutesChanged();\n    }\n  }\n  componentDidLoad() {\n    window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n    window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n  }\n  async onPopState() {\n    const direction = this.historyDirection();\n    let segments = this.getSegments();\n    const canProceed = await this.runGuards(segments);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        segments = parsePath(canProceed.redirect).segments;\n      }\n      else {\n        return false;\n      }\n    }\n    return this.writeNavStateRoot(segments, direction);\n  }\n  onBackButton(ev) {\n    ev.detail.register(0, (processNextHandler) => {\n      this.back();\n      processNextHandler();\n    });\n  }\n  /** @internal */\n  async canTransition() {\n    const canProceed = await this.runGuards();\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        return canProceed.redirect;\n      }\n      else {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Navigate to the specified path.\n   *\n   * @param path The path to navigate to.\n   * @param direction The direction of the animation. Defaults to `\"forward\"`.\n   */\n  async push(path, direction = 'forward', animation) {\n    var _a;\n    if (path.startsWith('.')) {\n      const currentPath = (_a = this.previousPath) !== null && _a !== void 0 ? _a : '/';\n      // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.\n      const url = new URL(path, `https://host/${currentPath}`);\n      path = url.pathname + url.search;\n    }\n    let parsedPath = parsePath(path);\n    const canProceed = await this.runGuards(parsedPath.segments);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        parsedPath = parsePath(canProceed.redirect);\n      }\n      else {\n        return false;\n      }\n    }\n    this.setSegments(parsedPath.segments, direction, parsedPath.queryString);\n    return this.writeNavStateRoot(parsedPath.segments, direction, animation);\n  }\n  /** Go back to previous page in the window.history. */\n  back() {\n    window.history.back();\n    return Promise.resolve(this.waitPromise);\n  }\n  /** @internal */\n  async printDebug() {\n    printRoutes(readRoutes(this.el));\n    printRedirects(readRedirects(this.el));\n  }\n  /** @internal */\n  async navChanged(direction) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, navChanged was cancelled');\n      return false;\n    }\n    const { ids, outlet } = await readNavState(window.document.body);\n    const routes = readRoutes(this.el);\n    const chain = findChainForIDs(ids, routes);\n    if (!chain) {\n      console.warn('[ion-router] no matching URL for ', ids.map((i) => i.id));\n      return false;\n    }\n    const segments = chainToSegments(chain);\n    if (!segments) {\n      console.warn('[ion-router] router could not match path because some required param is missing');\n      return false;\n    }\n    this.setSegments(segments, direction);\n    await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);\n    return true;\n  }\n  /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */\n  onRedirectChanged() {\n    const segments = this.getSegments();\n    if (segments && findRouteRedirect(segments, readRedirects(this.el))) {\n      this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);\n    }\n  }\n  /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */\n  onRoutesChanged() {\n    return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);\n  }\n  historyDirection() {\n    var _a;\n    const win = window;\n    if (win.history.state === null) {\n      this.state++;\n      win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);\n    }\n    const state = win.history.state;\n    const lastState = this.lastState;\n    this.lastState = state;\n    if (state > lastState || (state >= lastState && lastState > 0)) {\n      return ROUTER_INTENT_FORWARD;\n    }\n    if (state < lastState) {\n      return ROUTER_INTENT_BACK;\n    }\n    return ROUTER_INTENT_NONE;\n  }\n  async writeNavStateRoot(segments, direction, animation) {\n    if (!segments) {\n      console.error('[ion-router] URL is not part of the routing set');\n      return false;\n    }\n    // lookup redirect rule\n    const redirects = readRedirects(this.el);\n    const redirect = findRouteRedirect(segments, redirects);\n    let redirectFrom = null;\n    if (redirect) {\n      const { segments: toSegments, queryString } = redirect.to;\n      this.setSegments(toSegments, direction, queryString);\n      redirectFrom = redirect.from;\n      segments = toSegments;\n    }\n    // lookup route chain\n    const routes = readRoutes(this.el);\n    const chain = findChainForSegments(segments, routes);\n    if (!chain) {\n      console.error('[ion-router] the path does not match any route');\n      return false;\n    }\n    // write DOM give\n    return this.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation);\n  }\n  async safeWriteNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise((r) => (resolve = r));\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  /**\n   * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.\n   *\n   * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.\n   * Otherwise the beforeEnterHook hook of the target route is executed.\n   */\n  async runGuards(to = this.getSegments(), from) {\n    if (from === undefined) {\n      from = parsePath(this.previousPath).segments;\n    }\n    if (!to || !from) {\n      return true;\n    }\n    const routes = readRoutes(this.el);\n    const fromChain = findChainForSegments(from, routes);\n    const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\n    const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;\n    if (canLeave === false || typeof canLeave === 'object') {\n      return canLeave;\n    }\n    const toChain = findChainForSegments(to, routes);\n    const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\n    return beforeEnterHook ? beforeEnterHook() : true;\n  }\n  async writeNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, transition was cancelled');\n      return false;\n    }\n    this.busy = true;\n    // generate route event and emit will change\n    const routeEvent = this.routeChangeEvent(segments, redirectFrom);\n    if (routeEvent) {\n      this.ionRouteWillChange.emit(routeEvent);\n    }\n    const changed = await writeNavState(node, chain, direction, index, false, animation);\n    this.busy = false;\n    // emit did change\n    if (routeEvent) {\n      this.ionRouteDidChange.emit(routeEvent);\n    }\n    return changed;\n  }\n  setSegments(segments, direction, queryString) {\n    this.state++;\n    writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);\n  }\n  getSegments() {\n    return readSegments(window.location, this.root, this.useHash);\n  }\n  routeChangeEvent(toSegments, redirectFromSegments) {\n    const from = this.previousPath;\n    const to = generatePath(toSegments);\n    this.previousPath = to;\n    if (to === from) {\n      return null;\n    }\n    const redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;\n    return {\n      from,\n      redirectedFrom,\n      to,\n    };\n  }\n  static get is() { return \"ion-router\"; }\n  static get properties() {\n    return {\n      \"root\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The root path to use when matching URLs. By default, this is set to \\\"/\\\", but you can specify\\nan alternate prefix for all URL paths.\"\n        },\n        \"attribute\": \"root\",\n        \"reflect\": false,\n        \"defaultValue\": \"'/'\"\n      },\n      \"useHash\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The router can work in two \\\"modes\\\":\\n- With hash: `/index.html#/path/to/page`\\n- Without hash: `/path/to/page`\\n\\nUsing one or another might depend in the requirements of your app and/or where it's deployed.\\n\\nUsually \\\"hash-less\\\" navigation works better for SEO and it's more user friendly too, but it might\\nrequires additional server-side configuration in order to properly work.\\n\\nOn the other side hash-navigation is much easier to deploy, it even works over the file protocol.\\n\\nBy default, this property is `true`, change to `false` to allow hash-less URLs.\"\n        },\n        \"attribute\": \"use-hash\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionRouteWillChange\",\n        \"name\": \"ionRouteWillChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Event emitted when the route is about to change\"\n        },\n        \"complexType\": {\n          \"original\": \"RouterEventDetail\",\n          \"resolved\": \"RouterEventDetail\",\n          \"references\": {\n            \"RouterEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./utils/interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionRouteDidChange\",\n        \"name\": \"ionRouteDidChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the route had changed\"\n        },\n        \"complexType\": {\n          \"original\": \"RouterEventDetail\",\n          \"resolved\": \"RouterEventDetail\",\n          \"references\": {\n            \"RouterEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./utils/interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"canTransition\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<string | boolean>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<string | boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"push\": {\n        \"complexType\": {\n          \"signature\": \"(path: string, direction?: RouterDirection, animation?: AnimationBuilder) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"path The path to navigate to.\"\n                }],\n              \"text\": \"The path to navigate to.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"direction The direction of the animation. Defaults to `\\\"forward\\\"`.\"\n                }],\n              \"text\": \"The direction of the animation. Defaults to `\\\"forward\\\"`.\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouterDirection\": {\n              \"location\": \"import\",\n              \"path\": \"./utils/interface\"\n            },\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Navigate to the specified path.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"path The path to navigate to.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"direction The direction of the animation. Defaults to `\\\"forward\\\"`.\"\n            }]\n        }\n      },\n      \"back\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Go back to previous page in the window.history.\",\n          \"tags\": []\n        }\n      },\n      \"printDebug\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"navChanged\": {\n        \"complexType\": {\n          \"signature\": \"(direction: RouterDirection) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouterDirection\": {\n              \"location\": \"import\",\n              \"path\": \"./utils/interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get listeners() {\n    return [{\n        \"name\": \"popstate\",\n        \"method\": \"onPopState\",\n        \"target\": \"window\",\n        \"capture\": false,\n        \"passive\": false\n      }, {\n        \"name\": \"ionBackButton\",\n        \"method\": \"onBackButton\",\n        \"target\": \"document\",\n        \"capture\": false,\n        \"passive\": false\n      }];\n  }\n}\n",":host {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  contain: layout size style;\n  overflow: hidden;\n  z-index: 0;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { h } from '@stencil/core';\nimport { getTimeGivenProgression } from \"../../utils/animation/cubic-bezier\";\nimport { attachComponent, detachComponent } from \"../../utils/framework-delegate\";\nimport { shallowEqualStringMap, hasLazyBuild } from \"../../utils/helpers\";\nimport { transition } from \"../../utils/transition/index\";\nimport { config } from '../../global/config';\nimport { getIonMode } from '../../global/ionic-global';\nexport class RouterOutlet {\n  constructor() {\n    this.gestureOrAnimationInProgress = false;\n    this.mode = getIonMode(this);\n    this.delegate = undefined;\n    this.animated = true;\n    this.animation = undefined;\n    this.swipeHandler = undefined;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await import('../../utils/gesture/swipe-back')).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => { var _a; return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step); }, (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation,\n    });\n    return {\n      changed,\n      element: this.activeEl,\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active\n      ? {\n        id: active.tagName,\n        element: active,\n        params: this.activeParams,\n      }\n      : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || config.get('navAnimation');\n    await transition(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el,\n      /**\n       * We need to wait for all Stencil components\n       * to be ready only when using the lazy\n       * loaded bundle.\n       */\n      deepWait: hasLazyBuild(el), progressCallback: opts.progressAnimation\n        ? (ani) => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise((r) => (resolve = r));\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return h(\"slot\", null);\n  }\n  static get is() { return \"ion-router-outlet\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"route-outlet.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"route-outlet.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"mode\": {\n        \"type\": \"string\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"\\\"ios\\\" | \\\"md\\\"\",\n          \"resolved\": \"\\\"ios\\\" | \\\"md\\\"\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The mode determines which platform styles to use.\"\n        },\n        \"attribute\": \"mode\",\n        \"reflect\": false,\n        \"defaultValue\": \"getIonMode(this)\"\n      },\n      \"delegate\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"FrameworkDelegate\",\n          \"resolved\": \"FrameworkDelegate | undefined\",\n          \"references\": {\n            \"FrameworkDelegate\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        }\n      },\n      \"animated\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the router-outlet should animate the transition of components.\"\n        },\n        \"attribute\": \"animated\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"animation\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"AnimationBuilder\",\n          \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n          \"references\": {\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"This property allows to create custom transition using AnimationBuilder functions.\"\n        }\n      },\n      \"swipeHandler\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"SwipeGestureHandler\",\n          \"resolved\": \"SwipeGestureHandler | undefined\",\n          \"references\": {\n            \"SwipeGestureHandler\": {\n              \"location\": \"import\",\n              \"path\": \"../nav/nav-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        }\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionNavWillLoad\",\n        \"name\": \"ionNavWillLoad\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionNavWillChange\",\n        \"name\": \"ionNavWillChange\",\n        \"bubbles\": false,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionNavDidChange\",\n        \"name\": \"ionNavDidChange\",\n        \"bubbles\": false,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"commit\": {\n        \"complexType\": {\n          \"signature\": \"(enteringEl: HTMLElement, leavingEl: HTMLElement | undefined, opts?: RouterOutletOptions) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            },\n            \"RouterOutletOptions\": {\n              \"location\": \"import\",\n              \"path\": \"../nav/nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"setRouteId\": {\n        \"complexType\": {\n          \"signature\": \"(id: string, params: ComponentProps | undefined, direction: RouterDirection, animation?: AnimationBuilder) => Promise<RouteWrite>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }, {\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouteWrite\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            },\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"RouterDirection\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            },\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          },\n          \"return\": \"Promise<RouteWrite>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"getRouteId\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<RouteID | undefined>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouteID\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            }\n          },\n          \"return\": \"Promise<RouteID | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"swipeHandler\",\n        \"methodName\": \"swipeHandlerChanged\"\n      }];\n  }\n}\n"],"mappings":"gbAAA,MAAMA,EAAa,G,MCWNC,EAAO,M,yBAClB,MAAAC,GACE,OACEC,EAAA,eACEA,EAAA,cAAYC,QAAS,MAAOC,IAAKC,GAAMC,EAAeC,iBAAmBF,GACvEH,EAAA,sBAAoBM,KAAK,IAAIC,GAAG,WAChCP,EAAA,aAAWQ,IAAI,SAASC,UAAU,eAClCT,EAAA,aAAWQ,IAAI,UAAUC,UAAU,gBAClCC,EAASC,KAAIC,GACZZ,EAAA,aACEQ,IAAKI,EAAEJ,IACPC,UAAWG,EAAEH,UACbI,YAAa,KACX,GAAIC,EAAMF,EAAEG,OAAS,SAAU,CAC7B,MAAMC,EAAiC,CACrCA,SAAU,WAEZ,OAAOA,C,CAET,OAAO,IAAI,MAIjBhB,EAAA,aAAWQ,IAAI,YAAYC,UAAU,kBACrCT,EAAA,aAAWQ,IAAI,aAAaC,UAAU,wBAGxCT,EAAA,0BAEAA,EAAA,KAAGiB,MAAO,CAAEC,QAAS,QAAUC,KAAK,WACpCnB,EAAA,KAAGiB,MAAO,CAAEC,QAAS,QAAUC,KAAK,Y,aCzC5C,MAAMC,EAAS,gK,MCOFC,EAAG,M,yBACd,gBAAAC,GACuB,CACnBC,GAAIC,UACF,MAAMC,EAAWC,EAAWC,OAAQ,UACpC,IAAKC,EAAOC,WAAW,YAAa,CAClCC,OAAO,mBAAyBC,MAAMC,GAAWA,EAAOC,cAAcL,I,CAExE,GAAIA,EAAOC,WAAW,YAAaJ,GAAW,CAC5CK,OAAO,mBAA0BC,MAAMC,GAAWA,EAAOE,kB,CAE3D,GAAIN,EAAOC,WAAW,aAAcM,KAAmB,CAKrD,MAAMC,EAAWV,EAAWC,OAAQ,OAAS,MAAQ,UACrDG,OAAO,mBAAuCC,MAAMC,GAAWA,EAAOK,gBAAgBT,EAAQQ,I,CAEhG,MAAME,QAAiCR,OAAO,mBAC9C,GAAIF,EAAOC,WAAW,qBAAsBJ,GAAW,CACrDa,EAAyBC,yB,KAEtB,CACHD,EAAyBE,yB,CAE3B,UAAWb,SAAW,YAAa,CACjCG,OAAO,mBAAiCC,MAAMC,GAAWA,EAAOS,oBAAoBd,S,CAEtFG,OAAO,mBAA6BC,MAAMC,GAAYU,KAAKC,aAAeX,EAAOY,qBAAqB,G,EAc5G,cAAMC,CAASC,GACb,GAAIJ,KAAKC,aAAc,CACrBD,KAAKC,aAAaE,SAASC,E,EAG/B,MAAA/C,GACE,MAAMgD,EAAOC,EAAWN,MACxB,OAAQ1C,EAAEiD,EAAM,CAAEC,MAAO,CACrBH,CAACA,GAAO,KACR,WAAY,KACZ,0BAA2BnB,EAAOC,WAAW,4B,2BA6CrD,MAAMM,EAAiB,KAIrB,MAAMgB,EAAgBzB,EAAWC,OAAQ,QAAUD,EAAWC,OAAQ,UACtE,GAAIwB,EAAe,CACjB,OAAO,I,CAOT,MAAMC,EAAqB1B,EAAWC,OAAQ,YAAcD,EAAWC,OAAQ,aAC/E,GAAIyB,EAAoB,CACtB,OAAO,I,CAET,OAAO,KAAK,EAEd,MAAM7B,EAAO8B,IACX,GAAI,wBAAyB1B,OAAQ,CACnCA,OAAO2B,oBAAoBD,E,KAExB,CACHE,WAAWF,EAAU,G,mBChIZG,EAAK,MAChB,WAAAC,CAAAC,G,mEACEhB,KAAKlC,IAAM,GACXkC,KAAKjC,UAAYkD,UACjBjB,KAAKkB,eAAiBD,UACtBjB,KAAKmB,YAAcF,UACnBjB,KAAK7B,YAAc8C,S,CAErB,QAAAG,CAASC,GACPrB,KAAKsB,oBAAoBC,KAAKF,E,CAEhC,gBAAAG,CAAiBH,EAAUI,GACzB,GAAIJ,IAAaI,EAAU,CACzB,M,CAEF,MAAMC,EAAQL,EAAWM,OAAOC,KAAKP,GAAY,GACjD,MAAMQ,EAAQJ,EAAWE,OAAOC,KAAKH,GAAY,GACjD,GAAIC,EAAMI,SAAWD,EAAMC,OAAQ,CACjC9B,KAAKoB,SAASC,GACd,M,CAEF,IAAK,MAAMhD,KAAOqD,EAAO,CACvB,GAAIL,EAAShD,KAASoD,EAASpD,GAAM,CACnC2B,KAAKoB,SAASC,GACd,M,GAIN,iBAAAU,GACE/B,KAAKsB,oBAAoBC,M,mHC9BhBS,EAAa,MACxB,WAAAjB,CAAAC,G,2EACEhB,KAAKpC,KAAOqD,UACZjB,KAAKnC,GAAKoD,S,CAEZ,aAAAgB,GACEjC,KAAKkC,wBAAwBX,M,CAE/B,iBAAAQ,GACE/B,KAAKkC,wBAAwBX,M;;;GCN1B,MAAMY,EAAqB,OAC3B,MAAMC,EAAwB,UAC9B,MAAMC,EAAqB;;;GCA3B,MAAMC,EAAgBC,IAC3B,MAAMC,EAAOD,EAASE,QAAQC,GAAMA,EAAEZ,OAAS,IAAGa,KAAK,KACvD,MAAO,IAAMH,CAAI,EAEnB,MAAMI,EAAc,CAACL,EAAUhF,EAASsF,KACtC,IAAI/E,EAAMwE,EAAaC,GACvB,GAAIhF,EAAS,CACXO,EAAM,IAAMA,CAChB,CACE,GAAI+E,IAAgB5B,UAAW,CAC7BnD,GAAO,IAAM+E,CACjB,CACE,OAAO/E,CAAG,EAEL,MAAMgF,EAAgB,CAACC,EAASC,EAAMzF,EAASgF,EAAUU,EAAW7E,EAAOyE,KAChF,MAAM/E,EAAM8E,EAAY,IAAIM,EAAUF,GAAMT,YAAaA,GAAWhF,EAASsF,GAC7E,GAAII,IAAcb,EAAuB,CACvCW,EAAQI,UAAU/E,EAAO,GAAIN,EACjC,KACO,CACHiF,EAAQK,aAAahF,EAAO,GAAIN,EACpC,GASO,MAAMuF,EAAmBC,IAC9B,MAAMf,EAAW,GACjB,IAAK,MAAMgB,KAASD,EAAO,CACzB,IAAK,MAAME,KAAWD,EAAMhB,SAAU,CACpC,GAAIiB,EAAQ,KAAO,IAAK,CACtB,MAAMC,EAAQF,EAAMG,QAAUH,EAAMG,OAAOF,EAAQG,MAAM,IACzD,IAAKF,EAAO,CACV,OAAO,IACjB,CACQlB,EAASqB,KAAKH,EACtB,MACW,GAAID,IAAY,GAAI,CACvBjB,EAASqB,KAAKJ,EACtB,CACA,CACA,CACE,OAAOjB,CAAQ,EASjB,MAAMsB,EAAe,CAACC,EAAQvB,KAC5B,GAAIuB,EAAOhC,OAASS,EAAST,OAAQ,CACnC,OAAO,IACX,CACE,GAAIgC,EAAOhC,QAAU,GAAKgC,EAAO,KAAO,GAAI,CAC1C,OAAOvB,CACX,CACE,IAAK,IAAIwB,EAAI,EAAGA,EAAID,EAAOhC,OAAQiC,IAAK,CACtC,GAAID,EAAOC,KAAOxB,EAASwB,GAAI,CAC7B,OAAO,IACb,CACA,CACE,GAAIxB,EAAST,SAAWgC,EAAOhC,OAAQ,CACrC,MAAO,CAAC,GACZ,CACE,OAAOS,EAASoB,MAAMG,EAAOhC,OAAO,EAE/B,MAAMkC,EAAe,CAACC,EAAKjB,EAAMzF,KACtC,MAAMuG,EAASZ,EAAUF,GAAMT,SAC/B,MAAM2B,EAAW3G,EAAU0G,EAAIE,KAAKR,MAAM,GAAKM,EAAIC,SACnD,MAAM3B,EAAWW,EAAUgB,GAAU3B,SACrC,OAAOsB,EAAaC,EAAQvB,EAAS,EAOhC,MAAMW,EAAaV,IACxB,IAAID,EAAW,CAAC,IAChB,IAAIM,EACJ,GAAIL,GAAQ,KAAM,CAChB,MAAM4B,EAAU5B,EAAK6B,QAAQ,KAC7B,GAAID,GAAW,EAAG,CAChBvB,EAAcL,EAAK8B,UAAUF,EAAU,GACvC5B,EAAOA,EAAK8B,UAAU,EAAGF,EAC/B,CACI7B,EAAWC,EACR+B,MAAM,KACNtG,KAAKyE,GAAMA,EAAE8B,SACb/B,QAAQC,GAAMA,EAAEZ,OAAS,IAC5B,GAAIS,EAAST,SAAW,EAAG,CACzBS,EAAW,CAAC,GAClB,CACA,CACE,MAAO,CAAEA,WAAUM,cAAa;;;GCrG3B,MAAM4B,EAAeC,IAC1BC,QAAQC,MAAM,qBAAqBF,EAAO5C,WAC1C,IAAK,MAAMwB,KAASoB,EAAQ,CAC1B,MAAMnC,EAAW,GACjBe,EAAMuB,SAASC,GAAMvC,EAASqB,QAAQkB,EAAEvC,YACxC,MAAMwC,EAAMzB,EAAMrF,KAAK6G,GAAMA,EAAEE,KAC/BL,QAAQM,MAAM,MAAM3C,EAAaC,KAAa,wCAAyC,OAAQ,IAAIwC,EAAIpC,KAAK,SAChH,CACEgC,QAAQO,UAAU,EAEb,MAAMC,EAAkBC,IAC7BT,QAAQC,MAAM,wBAAwBQ,EAAUtD,WAChD,IAAK,MAAMxD,KAAY8G,EAAW,CAChC,GAAI9G,EAAST,GAAI,CACf8G,QAAQM,MAAM,SAAU,MAAM3C,EAAahE,EAASV,QAAS,oBAAqB,QAAS,MAAM0E,EAAahE,EAAST,GAAG0E,YAAa,oBAC7I,CACA,CACEoC,QAAQO,UAAU;;;GCRb,MAAMG,EAAgBvG,MAAOkE,EAAMM,EAAOL,EAAWqC,EAAOC,EAAU,MAAOC,KAClF,IAEE,MAAMC,EAASC,EAAc1C,GAE7B,GAAIsC,GAAShC,EAAMxB,SAAW2D,EAAQ,CACpC,OAAOF,CACb,OACU,IAAII,SAASC,GAAYC,EAAiBJ,EAAQG,KACxD,MAAMrC,EAAQD,EAAMgC,GACpB,MAAMQ,QAAeL,EAAOM,WAAWxC,EAAMyB,GAAIzB,EAAMG,OAAQT,EAAWuC,GAG1E,GAAIM,EAAOP,QAAS,CAClBtC,EAAYd,EACZoD,EAAU,IAChB,CAEIA,QAAgBF,EAAcS,EAAOE,QAAS1C,EAAOL,EAAWqC,EAAQ,EAAGC,EAASC,GAGpF,GAAIM,EAAOG,YAAa,OAChBH,EAAOG,aACnB,CACI,OAAOV,CACX,CACE,MAAO9H,GACLkH,QAAQuB,MAAMzI,GACd,OAAO,KACX,GAOO,MAAM0I,EAAerH,MAAOkE,IACjC,MAAM+B,EAAM,GACZ,IAAIU,EACJ,IAAIW,EAAOpD,EAEX,MAAQyC,EAASC,EAAcU,GAAQ,CACrC,MAAMpB,QAAWS,EAAOY,aACxB,GAAIrB,EAAI,CACNoB,EAAOpB,EAAGgB,QACVhB,EAAGgB,QAAU/E,UACb8D,EAAInB,KAAKoB,EACf,KACS,CACH,KACN,CACA,CACE,MAAO,CAAED,MAAKU,SAAQ,EAEjB,MAAMa,EAAmB,KAC9B,GAAIZ,EAAca,SAASC,MAAO,CAChC,OAAOb,QAAQC,SACnB,CACE,OAAO,IAAID,SAASC,IAClB3G,OAAOwH,iBAAiB,kBAAkB,IAAMb,KAAW,CAAEc,KAAM,MAAO,GAC1E,EAGJ,MAAMC,EAAkB,6FACxB,MAAMjB,EAAiB1C,IACrB,IAAKA,EAAM,CACT,OAAO/B,SACX,CACE,GAAI+B,EAAK4D,QAAQD,GAAkB,CACjC,OAAO3D,CACX,CACE,MAAMyC,EAASzC,EAAK6D,cAAcF,GAClC,OAAOlB,IAAW,MAAQA,SAAgB,EAAIA,EAASxE,SAAS;;;GC3E3D,MAAM6F,EAAkB,CAACvE,EAAUjE,KACxC,MAAMV,KAAEA,EAAIC,GAAEA,GAAOS,EACrB,GAAIT,IAAOoD,UAAW,CACpB,OAAO,KACX,CACE,GAAIrD,EAAKkE,OAASS,EAAST,OAAQ,CACjC,OAAO,KACX,CACE,IAAK,IAAIiC,EAAI,EAAGA,EAAInG,EAAKkE,OAAQiC,IAAK,CACpC,MAAMgD,EAAWnJ,EAAKmG,GACtB,GAAIgD,IAAa,IAAK,CACpB,OAAO,IACb,CACI,GAAIA,IAAaxE,EAASwB,GAAI,CAC5B,OAAO,KACb,CACA,CACE,OAAOnG,EAAKkE,SAAWS,EAAST,MAAM,EAGjC,MAAMkF,EAAoB,CAACzE,EAAU6C,IACnCA,EAAU6B,MAAM3I,GAAawI,EAAgBvE,EAAUjE,KAEzD,MAAM4I,EAAa,CAACnC,EAAKzB,KAC9B,MAAM6D,EAAMC,KAAKC,IAAItC,EAAIjD,OAAQwB,EAAMxB,QACvC,IAAIwF,EAAQ,EACZ,IAAK,IAAIvD,EAAI,EAAGA,EAAIoD,EAAKpD,IAAK,CAC5B,MAAMwD,EAAUxC,EAAIhB,GACpB,MAAMyD,EAAalE,EAAMS,GAEzB,GAAIwD,EAAQvC,GAAGyC,gBAAkBD,EAAWxC,GAAI,CAC9C,KACN,CACI,GAAIuC,EAAQ7D,OAAQ,CAClB,MAAMgE,EAAgB/F,OAAOC,KAAK2F,EAAQ7D,QAE1C,GAAIgE,EAAc5F,SAAW0F,EAAWjF,SAAST,OAAQ,CAmBvD,MAAM6F,EAAiBD,EAAczJ,KAAKI,GAAQ,IAAIA,MACtD,IAAK,IAAIuJ,EAAI,EAAGA,EAAID,EAAe7F,OAAQ8F,IAAK,CAE9C,GAAID,EAAeC,GAAGH,gBAAkBD,EAAWjF,SAASqF,GAAI,CAC9D,KACZ,CAEUN,GACV,CACA,CACA,CAEIA,GACJ,CACE,OAAOA,CAAK,EASP,MAAMO,EAAkB,CAACtF,EAAUe,KACxC,MAAMwE,EAAgB,IAAIC,EAAexF,GACzC,IAAIyF,EAAiB,MACrB,IAAIC,EACJ,IAAK,IAAIlE,EAAI,EAAGA,EAAIT,EAAMxB,OAAQiC,IAAK,CACrC,MAAMmE,EAAgB5E,EAAMS,GAAGxB,SAC/B,GAAI2F,EAAc,KAAO,GAAI,CAC3BF,EAAiB,IACvB,KACS,CACH,IAAK,MAAMxE,KAAW0E,EAAe,CACnC,MAAMC,EAAOL,EAAcM,OAE3B,GAAI5E,EAAQ,KAAO,IAAK,CACtB,GAAI2E,IAAS,GAAI,CACf,OAAO,IACnB,CACUF,EAAYA,GAAa,GACzB,MAAMvE,EAASuE,EAAUlE,KAAOkE,EAAUlE,GAAK,IAC/CL,EAAOF,EAAQG,MAAM,IAAMwE,CACrC,MACa,GAAIA,IAAS3E,EAAS,CACzB,OAAO,IACjB,CACA,CACMwE,EAAiB,KACvB,CACA,CACE,MAAMpB,EAAUoB,EAAiBA,KAAoBF,EAAcM,SAAW,IAAM,KACpF,IAAKxB,EAAS,CACZ,OAAO,IACX,CACE,GAAIqB,EAAW,CACb,OAAO3E,EAAMrF,KAAI,CAACsF,EAAOQ,KAAC,CACxBiB,GAAIzB,EAAMyB,GACVzC,SAAUgB,EAAMhB,SAChBmB,OAAQ2E,EAAY9E,EAAMG,OAAQuE,EAAUlE,IAC5C5F,YAAaoF,EAAMpF,YACnBgD,YAAaoC,EAAMpC,eAEzB,CACE,OAAOmC,CAAK,EAMP,MAAM+E,EAAc,CAACC,EAAGC,IACtBD,GAAKC,EAAI5G,OAAO6G,OAAO7G,OAAO6G,OAAO,GAAIF,GAAIC,GAAKtH,UASpD,MAAMwH,EAAkB,CAAC1D,EAAK2D,KACnC,IAAIC,EAAQ,KACZ,IAAIC,EAAa,EACjB,IAAK,MAAMtF,KAASoF,EAAQ,CAC1B,MAAMpB,EAAQJ,EAAWnC,EAAKzB,GAC9B,GAAIgE,EAAQsB,EAAY,CACtBD,EAAQrF,EACRsF,EAAatB,CACnB,CACA,CACE,GAAIqB,EAAO,CACT,OAAOA,EAAM1K,KAAI,CAACsF,EAAOQ,KACvB,IAAI8E,EACJ,OACE7D,GAAIzB,EAAMyB,GACVzC,SAAUgB,EAAMhB,SAChBmB,OAAQ2E,EAAY9E,EAAMG,QAASmF,EAAK9D,EAAIhB,MAAQ,MAAQ8E,SAAY,OAAS,EAAIA,EAAGnF,QACzF,GAEP,CACE,OAAO,IAAI,EASN,MAAMoF,EAAuB,CAACvG,EAAUmG,KAC7C,IAAIC,EAAQ,KACZ,IAAII,EAAY,EAChB,IAAK,MAAMzF,KAASoF,EAAQ,CAC1B,MAAMM,EAAenB,EAAgBtF,EAAUe,GAC/C,GAAI0F,IAAiB,KAAM,CACzB,MAAM1B,EAAQ2B,EAAgBD,GAC9B,GAAI1B,EAAQyB,EAAW,CACrBA,EAAYzB,EACZqB,EAAQK,CAChB,CACA,CACA,CACE,OAAOL,CAAK,EAaP,MAAMM,EAAmB3F,IAC9B,IAAIgE,EAAQ,EACZ,IAAI4B,EAAQ,EACZ,IAAK,MAAM3F,KAASD,EAAO,CACzB,IAAK,MAAME,KAAWD,EAAMhB,SAAU,CACpC,GAAIiB,EAAQ,KAAO,IAAK,CACtB8D,GAASF,KAAK+B,IAAI,EAAGD,EAC7B,MACW,GAAI1F,IAAY,GAAI,CACvB8D,GAASF,KAAK+B,IAAI,EAAGD,EAC7B,CACMA,GACN,CACA,CACE,OAAO5B,CAAK,EAEP,MAAMS,EACX,WAAAhH,CAAYwB,GACVvC,KAAKuC,SAAWA,EAASoB,OAC7B,CACE,IAAAyE,GACE,GAAIpI,KAAKuC,SAAST,OAAS,EAAG,CAC5B,OAAO9B,KAAKuC,SAAS6G,OAC3B,CACI,MAAO,EACX;;;GC7NA,MAAMC,EAAW,CAACC,EAAIC,KACpB,GAAIA,KAAQD,EAAI,CACd,OAAOA,EAAGC,EACd,CACE,GAAID,EAAGE,aAAaD,GAAO,CACzB,OAAOD,EAAGG,aAAaF,EAC3B,CACE,OAAO,IAAI,EAON,MAAMG,GAAiB1G,GACrB2G,MAAM/L,KAAKoF,EAAK4G,UACpBnH,QAAQ6G,GAAOA,EAAGO,UAAY,uBAC9B5L,KAAKqL,IACN,MAAMzL,EAAKwL,EAASC,EAAI,MACxB,MAAO,CACL1L,KAAMsF,EAAUmG,EAASC,EAAI,SAAS/G,SACtC1E,GAAIA,GAAM,KAAOoD,UAAYiC,EAAUrF,GACxC,IAQE,MAAMiM,GAAc9G,GAClB+G,GAAkBC,GAAehH,IAOnC,MAAMgH,GAAkB5D,GACtBuD,MAAM/L,KAAKwI,EAAKwD,UACpBnH,QAAQ6G,GAAOA,EAAGO,UAAY,aAAeP,EAAGvL,YAChDE,KAAKqL,IACN,MAAMvL,EAAYsL,EAASC,EAAI,aAC/B,MAAO,CACL/G,SAAUW,EAAUmG,EAASC,EAAI,QAAQ/G,SACzCyC,GAAIjH,EAAU0J,cACd/D,OAAQ4F,EAAGpI,eACXC,YAAamI,EAAGnI,YAChBhD,YAAamL,EAAGnL,YAChByL,SAAUI,GAAeV,GAC1B,IAQE,MAAMS,GAAqBE,IAChC,MAAMvB,EAAS,GACf,IAAK,MAAMtC,KAAQ6D,EAAO,CACxBC,GAAY,GAAIxB,EAAQtC,EAC5B,CACE,OAAOsC,CAAM,EAGf,MAAMwB,GAAc,CAAC5G,EAAOoF,EAAQtC,KAClC9C,EAAQ,IACHA,EACH,CACE0B,GAAIoB,EAAKpB,GACTzC,SAAU6D,EAAK7D,SACfmB,OAAQ0C,EAAK1C,OACbvC,YAAaiF,EAAKjF,YAClBhD,YAAaiI,EAAKjI,cAGtB,GAAIiI,EAAKwD,SAAS9H,SAAW,EAAG,CAC9B4G,EAAO9E,KAAKN,GACZ,MACJ,CACE,IAAK,MAAM6G,KAAS/D,EAAKwD,SAAU,CACjCM,GAAY5G,EAAOoF,EAAQyB,EAC/B,G,MChFaC,GAAM,MACjB,WAAArJ,CAAAC,G,sHACEhB,KAAKqK,aAAe,KACpBrK,KAAKsK,KAAO,MACZtK,KAAK5B,MAAQ,EACb4B,KAAKuK,UAAY,EACjBvK,KAAKgD,KAAO,IACZhD,KAAKzC,QAAU,I,CAEjB,uBAAMiN,SACElE,IACN,MAAMmE,QAAmBzK,KAAK0K,UAAU1K,KAAK2K,eAC7C,GAAIF,IAAe,KAAM,CACvB,UAAWA,IAAe,SAAU,CAClC,MAAMnM,SAAEA,GAAamM,EACrB,MAAMjI,EAAOU,EAAU5E,GACvB0B,KAAK4K,YAAYpI,EAAKD,SAAUJ,EAAoBK,EAAKK,mBACnD7C,KAAK6K,kBAAkBrI,EAAKD,SAAUJ,E,MAG3C,OACGnC,KAAK8K,iB,EAGf,gBAAAlM,GACEK,OAAOwH,iBAAiB,0BAA2BsE,EAAS/K,KAAKgL,kBAAkBC,KAAKjL,MAAO,KAC/Ff,OAAOwH,iBAAiB,sBAAuBsE,EAAS/K,KAAK8K,gBAAgBG,KAAKjL,MAAO,K,CAE3F,gBAAMkL,GACJ,MAAMjI,EAAYjD,KAAKmL,mBACvB,IAAI5I,EAAWvC,KAAK2K,cACpB,MAAMF,QAAmBzK,KAAK0K,UAAUnI,GACxC,GAAIkI,IAAe,KAAM,CACvB,UAAWA,IAAe,SAAU,CAClClI,EAAWW,EAAUuH,EAAWnM,UAAUiE,Q,KAEvC,CACH,OAAO,K,EAGX,OAAOvC,KAAK6K,kBAAkBtI,EAAUU,E,CAE1C,YAAAmI,CAAaC,GACXA,EAAGC,OAAOC,SAAS,GAAIC,IACrBxL,KAAKyL,OACLD,GAAoB,G,CAIxB,mBAAME,GACJ,MAAMjB,QAAmBzK,KAAK0K,YAC9B,GAAID,IAAe,KAAM,CACvB,UAAWA,IAAe,SAAU,CAClC,OAAOA,EAAWnM,Q,KAEf,CACH,OAAO,K,EAGX,OAAO,I,CAQT,UAAMsF,CAAKpB,EAAMS,EAAY,UAAWuC,GACtC,IAAIqD,EACJ,GAAIrG,EAAKmJ,WAAW,KAAM,CACxB,MAAMC,GAAe/C,EAAK7I,KAAKqK,gBAAkB,MAAQxB,SAAY,EAAIA,EAAK,IAE9E,MAAM/K,EAAM,IAAI+N,IAAIrJ,EAAM,gBAAgBoJ,KAC1CpJ,EAAO1E,EAAIoG,SAAWpG,EAAIgO,M,CAE5B,IAAIC,EAAa7I,EAAUV,GAC3B,MAAMiI,QAAmBzK,KAAK0K,UAAUqB,EAAWxJ,UACnD,GAAIkI,IAAe,KAAM,CACvB,UAAWA,IAAe,SAAU,CAClCsB,EAAa7I,EAAUuH,EAAWnM,S,KAE/B,CACH,OAAO,K,EAGX0B,KAAK4K,YAAYmB,EAAWxJ,SAAUU,EAAW8I,EAAWlJ,aAC5D,OAAO7C,KAAK6K,kBAAkBkB,EAAWxJ,SAAUU,EAAWuC,E,CAGhE,IAAAiG,GACExM,OAAO8D,QAAQ0I,OACf,OAAO9F,QAAQC,QAAQ5F,KAAKgM,Y,CAG9B,gBAAMC,GACJxH,EAAYqF,GAAW9J,KAAKsJ,KAC5BnE,EAAeuE,GAAc1J,KAAKsJ,I,CAGpC,gBAAM4C,CAAWjJ,GACf,GAAIjD,KAAKsK,KAAM,CACb3F,QAAQwH,KAAK,yDACb,OAAO,K,CAET,MAAMpH,IAAEA,EAAGU,OAAEA,SAAiBU,EAAalH,OAAOsH,SAASC,MAC3D,MAAM9B,EAASoF,GAAW9J,KAAKsJ,IAC/B,MAAMhG,EAAQmF,EAAgB1D,EAAKL,GACnC,IAAKpB,EAAO,CACVqB,QAAQwH,KAAK,oCAAqCpH,EAAI9G,KAAK8F,GAAMA,EAAEiB,MACnE,OAAO,K,CAET,MAAMzC,EAAWc,EAAgBC,GACjC,IAAKf,EAAU,CACboC,QAAQwH,KAAK,mFACb,OAAO,K,CAETnM,KAAK4K,YAAYrI,EAAUU,SACrBjD,KAAKoM,kBAAkB3G,EAAQnC,EAAOnB,EAAoBI,EAAU,KAAMwC,EAAIjD,QACpF,OAAO,I,CAGT,iBAAAkJ,GACE,MAAMzI,EAAWvC,KAAK2K,cACtB,GAAIpI,GAAYyE,EAAkBzE,EAAUmH,GAAc1J,KAAKsJ,KAAM,CACnEtJ,KAAK6K,kBAAkBtI,EAAUJ,E,EAIrC,eAAA2I,GACE,OAAO9K,KAAK6K,kBAAkB7K,KAAK2K,cAAexI,E,CAEpD,gBAAAgJ,GACE,IAAItC,EACJ,MAAMwD,EAAMpN,OACZ,GAAIoN,EAAItJ,QAAQ3E,QAAU,KAAM,CAC9B4B,KAAK5B,QACLiO,EAAItJ,QAAQK,aAAapD,KAAK5B,MAAOiO,EAAI9F,SAAS+F,OAAQzD,EAAKwD,EAAI9F,SAASgG,YAAc,MAAQ1D,SAAY,OAAS,EAAIA,EAAGpK,K,CAEhI,MAAML,EAAQiO,EAAItJ,QAAQ3E,MAC1B,MAAMmM,EAAYvK,KAAKuK,UACvBvK,KAAKuK,UAAYnM,EACjB,GAAIA,EAAQmM,GAAcnM,GAASmM,GAAaA,EAAY,EAAI,CAC9D,OAAOnI,C,CAET,GAAIhE,EAAQmM,EAAW,CACrB,OAAOlI,C,CAET,OAAOF,C,CAET,uBAAM0I,CAAkBtI,EAAUU,EAAWuC,GAC3C,IAAKjD,EAAU,CACboC,QAAQuB,MAAM,mDACd,OAAO,K,CAGT,MAAMd,EAAYsE,GAAc1J,KAAKsJ,IACrC,MAAMhL,EAAW0I,EAAkBzE,EAAU6C,GAC7C,IAAIoH,EAAe,KACnB,GAAIlO,EAAU,CACZ,MAAQiE,SAAUkK,EAAU5J,YAAEA,GAAgBvE,EAAST,GACvDmC,KAAK4K,YAAY6B,EAAYxJ,EAAWJ,GACxC2J,EAAelO,EAASV,KACxB2E,EAAWkK,C,CAGb,MAAM/H,EAASoF,GAAW9J,KAAKsJ,IAC/B,MAAMhG,EAAQwF,EAAqBvG,EAAUmC,GAC7C,IAAKpB,EAAO,CACVqB,QAAQuB,MAAM,kDACd,OAAO,K,CAGT,OAAOlG,KAAKoM,kBAAkB7F,SAASC,KAAMlD,EAAOL,EAAWV,EAAUiK,EAAc,EAAGhH,E,CAE5F,uBAAM4G,CAAkBhG,EAAM9C,EAAOL,EAAWV,EAAUiK,EAAclH,EAAQ,EAAGE,GACjF,MAAMkH,QAAe1M,KAAK2M,OAC1B,IAAIpH,EAAU,MACd,IACEA,QAAgBvF,KAAKqF,cAAce,EAAM9C,EAAOL,EAAWV,EAAUiK,EAAclH,EAAOE,E,CAE5F,MAAO/H,GACLkH,QAAQuB,MAAMzI,E,CAEhBiP,IACA,OAAOnH,C,CAET,UAAMoH,GACJ,MAAMzO,EAAI8B,KAAKgM,YACf,IAAIpG,EACJ5F,KAAKgM,YAAc,IAAIrG,SAASb,GAAOc,EAAUd,IACjD,GAAI5G,IAAM+C,UAAW,OACb/C,C,CAER,OAAO0H,C,CAQT,eAAM8E,CAAU7M,EAAKmC,KAAK2K,cAAe/M,GACvC,GAAIA,IAASqD,UAAW,CACtBrD,EAAOsF,EAAUlD,KAAKqK,cAAc9H,Q,CAEtC,IAAK1E,IAAOD,EAAM,CAChB,OAAO,I,CAET,MAAM8G,EAASoF,GAAW9J,KAAKsJ,IAC/B,MAAMsD,EAAY9D,EAAqBlL,EAAM8G,GAC7C,MAAMmI,EAAkBD,GAAaA,EAAUA,EAAU9K,OAAS,GAAGX,YACrE,MAAM2L,EAAWD,QAAwBA,IAAoB,KAC7D,GAAIC,IAAa,cAAgBA,IAAa,SAAU,CACtD,OAAOA,C,CAET,MAAMC,EAAUjE,EAAqBjL,EAAI6G,GACzC,MAAMsI,EAAkBD,GAAWA,EAAQA,EAAQjL,OAAS,GAAG3D,YAC/D,OAAO6O,EAAkBA,IAAoB,I,CAE/C,mBAAM3H,CAAce,EAAM9C,EAAOL,EAAWV,EAAUiK,EAAclH,EAAQ,EAAGE,GAC7E,GAAIxF,KAAKsK,KAAM,CACb3F,QAAQwH,KAAK,yDACb,OAAO,K,CAETnM,KAAKsK,KAAO,KAEZ,MAAM2C,EAAajN,KAAKkN,iBAAiB3K,EAAUiK,GACnD,GAAIS,EAAY,CACdjN,KAAKmN,mBAAmB5L,KAAK0L,E,CAE/B,MAAM1H,QAAgBF,EAAce,EAAM9C,EAAOL,EAAWqC,EAAO,MAAOE,GAC1ExF,KAAKsK,KAAO,MAEZ,GAAI2C,EAAY,CACdjN,KAAKoN,kBAAkB7L,KAAK0L,E,CAE9B,OAAO1H,C,CAET,WAAAqF,CAAYrI,EAAUU,EAAWJ,GAC/B7C,KAAK5B,QACL0E,EAAc7D,OAAO8D,QAAS/C,KAAKgD,KAAMhD,KAAKzC,QAASgF,EAAUU,EAAWjD,KAAK5B,MAAOyE,E,CAE1F,WAAA8H,GACE,OAAO3G,EAAa/E,OAAOsN,SAAUvM,KAAKgD,KAAMhD,KAAKzC,Q,CAEvD,gBAAA2P,CAAiBT,EAAYY,GAC3B,MAAMzP,EAAOoC,KAAKqK,aAClB,MAAMxM,EAAKyE,EAAamK,GACxBzM,KAAKqK,aAAexM,EACpB,GAAIA,IAAOD,EAAM,CACf,OAAO,I,CAET,MAAM0P,EAAiBD,EAAuB/K,EAAa+K,GAAwB,KACnF,MAAO,CACLzP,OACA0P,iBACAzP,K,2BCvQN,MAAM0P,GAAiB,6G,MCUVC,GAAY,MACvB,WAAAzM,CAAAC,G,6JACEhB,KAAKyN,6BAA+B,MACpCzN,KAAKK,KAAOC,EAAWN,MACvBA,KAAK0N,SAAWzM,UAChBjB,KAAK2N,SAAW,KAChB3N,KAAKwF,UAAYvE,UACjBjB,KAAK4N,aAAe3M,S,CAEtB,mBAAA4M,GACE,GAAI7N,KAAK8N,QAAS,CAChB9N,KAAK8N,QAAQC,OAAO/N,KAAK4N,eAAiB3M,U,EAG9C,uBAAMc,GACJ,MAAMiM,EAAU,KACdhO,KAAKyN,6BAA+B,KACpC,GAAIzN,KAAK4N,aAAc,CACrB5N,KAAK4N,aAAaI,S,GAGtBhO,KAAK8N,eAAiB1O,OAAO,oBAAmC6O,uBAAuBjO,KAAKsJ,IAAI,KAAOtJ,KAAKyN,gCAAkCzN,KAAK4N,cAAgB5N,KAAK4N,aAAaM,aAAY,IAAMF,MAAYG,IAAW,IAAItF,EAAI,OAAQA,EAAK7I,KAAKoO,OAAS,MAAQvF,SAAY,OAAS,EAAIA,EAAGwF,aAAaF,EAAK,IAAK,CAACG,EAAgBH,EAAMI,KACjV,GAAIvO,KAAKoO,IAAK,CACZpO,KAAKoO,IAAII,UAAS,KAChBxO,KAAKyN,6BAA+B,MACpC,GAAIzN,KAAK4N,aAAc,CACrB5N,KAAK4N,aAAaa,MAAMH,E,IAEzB,CAAEI,gBAAiB,OAEtB,IAAIC,EAAeL,GAAkB,KAAQ,KAS7C,IAAKA,EAAgB,CACnBtO,KAAKoO,IAAIQ,OAAO,kCAChBD,GAAgBE,EAAwB,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,IAAM,KAAO,CAAC,EAAG,GAAIV,GAAM,E,KAEjF,CACHQ,GAAgBE,EAAwB,CAAC,EAAG,GAAI,CAAC,IAAM,KAAO,CAAC,EAAG,GAAI,CAAC,EAAG,GAAIV,GAAM,E,CAEtFnO,KAAKoO,IAAIU,YAAYR,EAAiB,EAAI,EAAGK,EAAcJ,E,KAExD,CACHvO,KAAKyN,6BAA+B,K,KAGxCzN,KAAK6N,qB,CAEP,iBAAArD,GACExK,KAAK+O,eAAexN,M,CAEtB,oBAAAyN,GACE,GAAIhP,KAAK8N,QAAS,CAChB9N,KAAK8N,QAAQmB,UACbjP,KAAK8N,QAAU7M,S,EAInB,YAAMiO,CAAOC,EAAYC,EAAWC,GAClC,MAAM3C,QAAe1M,KAAK2M,OAC1B,IAAIpH,EAAU,MACd,IACEA,QAAgBvF,KAAKsP,WAAWH,EAAYC,EAAWC,E,CAEzD,MAAO5R,GACLkH,QAAQuB,MAAMzI,E,CAEhBiP,IACA,OAAOnH,C,CAGT,gBAAMQ,CAAWf,EAAItB,EAAQT,EAAWuC,GACtC,MAAMD,QAAgBvF,KAAKuP,QAAQvK,EAAItB,EAAQ,CAC7C8L,SAAUvM,IAAc,OAAS,EAAIhC,UACrCgC,UAAWA,IAAc,OAAS,OAAS,UAC3CwM,iBAAkBjK,IAEpB,MAAO,CACLD,UACAS,QAAShG,KAAK0P,S,CAIlB,gBAAMrJ,GACJ,MAAMsJ,EAAS3P,KAAK0P,SACpB,OAAOC,EACH,CACA3K,GAAI2K,EAAO9F,QACX7D,QAAS2J,EACTjM,OAAQ1D,KAAK4P,cAEb3O,S,CAEN,aAAMsO,CAAQxR,EAAW2F,EAAQ2L,GAC/B,GAAIrP,KAAK6P,kBAAoB9R,GAAa+R,EAAsBpM,EAAQ1D,KAAK4P,cAAe,CAC1F,OAAO,K,CAGT,MAAMR,EAAYpP,KAAK0P,SACvB,MAAMP,QAAmBY,EAAgB/P,KAAK0N,SAAU1N,KAAKsJ,GAAIvL,EAAW,CAAC,WAAY,sBAAuB2F,GAChH1D,KAAK6P,gBAAkB9R,EACvBiC,KAAK0P,SAAWP,EAChBnP,KAAK4P,aAAelM,QAEd1D,KAAKkP,OAAOC,EAAYC,EAAWC,SACnCW,EAAgBhQ,KAAK0N,SAAU0B,GACrC,OAAO,I,CAET,gBAAME,CAAWH,EAAYC,EAAWC,EAAO,IAC7C,GAAID,IAAcD,EAAY,CAC5B,OAAO,K,CAGTnP,KAAKiQ,iBAAiB1O,OACtB,MAAM+H,GAAEA,EAAEjJ,KAAEA,GAASL,KACrB,MAAM2N,EAAW3N,KAAK2N,UAAYzO,EAAOC,WAAW,WAAY,MAChE,MAAMsQ,EAAmBJ,EAAKI,kBAAoBzP,KAAKwF,WAAatG,EAAOgR,IAAI,sBACzEZ,EAAW3N,OAAO6G,OAAO7G,OAAO6G,OAAO,CAAEnI,OAC7CsN,WACAwB,aACAC,YAAWe,OAAQ7G,EAMnB8G,SAAUC,EAAa/G,GAAKgH,iBAAkBjB,EAAKkB,kBAC9CnC,IAQD,GAAIA,IAAQnN,YAAcjB,KAAKyN,6BAA8B,CAC3DzN,KAAKyN,6BAA+B,KACpCW,EAAII,UAAS,KACXxO,KAAKyN,6BAA+B,MACpC,GAAIzN,KAAK4N,aAAc,CACrB5N,KAAK4N,aAAaa,MAAM,M,IAEzB,CAAEC,gBAAiB,OAOtBN,EAAIU,YAAY,EAAG,EAAG,E,KAEnB,CACH9O,KAAKoO,IAAMA,C,GAGbnN,WAAaoO,GAAO,CAAEI,sBAE5BzP,KAAKwQ,gBAAgBjP,OACrB,OAAO,I,CAET,UAAMoL,GACJ,MAAMzO,EAAI8B,KAAKgM,YACf,IAAIpG,EACJ5F,KAAKgM,YAAc,IAAIrG,SAASb,GAAOc,EAAUd,IACjD,GAAI5G,IAAM+C,UAAW,OACb/C,C,CAER,OAAO0H,C,CAET,MAAAvI,GACE,OAAOC,EAAE,OAAQ,K"}