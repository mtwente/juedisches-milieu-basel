{"version":3,"names":["pickerColumnInternalIosCss","pickerColumnInternalMdCss","PickerColumnInternal","constructor","hostRef","this","isScrolling","isColumnVisible","canExitInputMode","centerPickerItemInView","target","smooth","el","top","offsetTop","clientHeight","scrollTop","scroll","left","behavior","undefined","setPickerItemActiveState","item","isActive","classList","add","PICKER_ITEM_ACTIVE_CLASS","part","PICKER_ITEM_ACTIVE_PART","remove","inputModeChange","ev","numericInput","useInputMode","inputModeColumn","detail","isColumnActive","setInputModeActive","state","scrollEndCallback","initializeScrollListener","enableHaptics","isPlatform","timeout","activeEl","activeItem","scrollCallback","raf","clearTimeout","hapticSelectionStart","bbox","getBoundingClientRect","centerX","x","width","centerY","y","height","activeElement","shadowRoot","elementFromPoint","disabled","hapticSelectionChanged","exitInputMode","setTimeout","hapticSelectionEnd","dataIndex","getAttribute","index","parseInt","selectedItem","items","value","setValue","addEventListener","destroyScrollListener","removeEventListener","parentEl","color","valueChange","scrollActiveItemIntoView","componentWillLoad","visibleCallback","entries","isIntersecting","oldActive","getElementRoot","querySelector","IntersectionObserver","threshold","observe","closest","componentDidRender","_a","findItem","find","ionChange","emit","render","mode","getIonMode","h","Host","exportparts","PICKER_ITEM_PART","tabindex","class","createColorClasses","map","onClick","text","pickerInternalIosCss","pickerInternalMdCss","PickerInternal","isInHighlightBounds","highlightEl","outsideX","clientX","right","outsideY","clientY","bottom","onFocusOut","relatedTarget","tagName","inputEl","onFocusIn","actionOnClick","columnEl","allowInput","enterInputMode","onPointerDown","columns","querySelectorAll","length","focusInput","hasInputColumn","destroyKeypressListener","focus","onKeyPress","emitInputModeChange","parsedValue","key","Number","isNaN","onInputChange","selectSingleColumn","singleColumnSearchTimeout","values","filter","startIndex","newString","substring","findItemFromCompleteValue","parsedText","replace","changedCharacter","searchColumn","colEl","zeroBehavior","selectMultiColumn","numericPickers","Array","from","col","firstColumn","lastColumn","minuteValue","firstCharacter","firstCharacterAgain","firstCharacterAgainAgain","minuteValueAgain","ionInputModeChange","preventTouchStartPropagation","stopPropagation","blur","inputmode","type","ref","onInput","onBlur"],"sources":["node_modules/@ionic/core/dist/collection/components/picker-column-internal/picker-column-internal.ios.css?tag=ion-picker-column-internal&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-column-internal/picker-column-internal.md.css?tag=ion-picker-column-internal&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-column-internal/picker-column-internal.js","node_modules/@ionic/core/dist/collection/components/picker-internal/picker-internal.ios.css?tag=ion-picker-internal&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-internal/picker-internal.md.css?tag=ion-picker-internal&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/picker-internal/picker-internal.js"],"sourcesContent":[":host {\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 0px;\n  padding-bottom: 0px;\n  height: 200px;\n  outline: none;\n  font-size: 22px;\n  scroll-snap-type: y mandatory;\n  /**\n   * Need to explicitly set overflow-x: hidden\n   * for older implementations of scroll snapping.\n   */\n  overflow-x: hidden;\n  overflow-y: scroll;\n  scrollbar-width: none;\n  text-align: center;\n}\n\n/**\n * Hide scrollbars on Chrome and Safari\n */\n:host::-webkit-scrollbar {\n  display: none;\n}\n\n:host .picker-item {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  display: block;\n  width: 100%;\n  height: 34px;\n  border: 0px;\n  outline: none;\n  background: transparent;\n  color: inherit;\n  font-family: var(--ion-font-family, inherit);\n  font-size: inherit;\n  line-height: 34px;\n  text-align: inherit;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n  scroll-snap-align: center;\n}\n\n:host .picker-item-empty,\n:host .picker-item.picker-item-disabled {\n  scroll-snap-align: none;\n  cursor: default;\n}\n\n:host .picker-item.picker-item-disabled {\n  opacity: 0.4;\n}\n\n:host(.picker-column-active) .picker-item.picker-item-active {\n  color: var(--ion-color-base);\n}\n\n@media (any-hover: hover) {\n  :host(:focus) {\n    outline: none;\n    background: rgba(var(--ion-color-base-rgb), 0.2);\n  }\n}",":host {\n  -webkit-padding-start: 16px;\n  padding-inline-start: 16px;\n  -webkit-padding-end: 16px;\n  padding-inline-end: 16px;\n  padding-top: 0px;\n  padding-bottom: 0px;\n  height: 200px;\n  outline: none;\n  font-size: 22px;\n  scroll-snap-type: y mandatory;\n  /**\n   * Need to explicitly set overflow-x: hidden\n   * for older implementations of scroll snapping.\n   */\n  overflow-x: hidden;\n  overflow-y: scroll;\n  scrollbar-width: none;\n  text-align: center;\n}\n\n/**\n * Hide scrollbars on Chrome and Safari\n */\n:host::-webkit-scrollbar {\n  display: none;\n}\n\n:host .picker-item {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  display: block;\n  width: 100%;\n  height: 34px;\n  border: 0px;\n  outline: none;\n  background: transparent;\n  color: inherit;\n  font-family: var(--ion-font-family, inherit);\n  font-size: inherit;\n  line-height: 34px;\n  text-align: inherit;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  overflow: hidden;\n  scroll-snap-align: center;\n}\n\n:host .picker-item-empty,\n:host .picker-item.picker-item-disabled {\n  scroll-snap-align: none;\n  cursor: default;\n}\n\n:host .picker-item.picker-item-disabled {\n  opacity: 0.4;\n}\n\n:host(.picker-column-active) .picker-item.picker-item-active {\n  color: var(--ion-color-base);\n}\n\n@media (any-hover: hover) {\n  :host(:focus) {\n    outline: none;\n    background: rgba(var(--ion-color-base-rgb), 0.2);\n  }\n}\n:host .picker-item-active {\n  color: var(--ion-color-base);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getElementRoot, raf } from \"../../utils/helpers\";\nimport { hapticSelectionChanged, hapticSelectionEnd, hapticSelectionStart } from \"../../utils/native/haptic\";\nimport { isPlatform } from \"../../utils/platform\";\nimport { createColorClasses } from \"../../utils/theme\";\nimport { getIonMode } from '../../global/ionic-global';\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n * @internal\n */\nexport class PickerColumnInternal {\n  constructor() {\n    this.isScrolling = false;\n    this.isColumnVisible = false;\n    this.canExitInputMode = true;\n    this.centerPickerItemInView = (target, smooth = true, canExitInputMode = true) => {\n      const { el, isColumnVisible } = this;\n      if (isColumnVisible) {\n        // (Vertical offset from parent) - (three empty picker rows) + (half the height of the target to ensure the scroll triggers)\n        const top = target.offsetTop - 3 * target.clientHeight + target.clientHeight / 2;\n        if (el.scrollTop !== top) {\n          /**\n           * Setting this flag prevents input\n           * mode from exiting in the picker column's\n           * scroll callback. This is useful when the user manually\n           * taps an item or types on the keyboard as both\n           * of these can cause a scroll to occur.\n           */\n          this.canExitInputMode = canExitInputMode;\n          el.scroll({\n            top,\n            left: 0,\n            behavior: smooth ? 'smooth' : undefined,\n          });\n        }\n      }\n    };\n    this.setPickerItemActiveState = (item, isActive) => {\n      if (isActive) {\n        item.classList.add(PICKER_ITEM_ACTIVE_CLASS);\n        item.part.add(PICKER_ITEM_ACTIVE_PART);\n      }\n      else {\n        item.classList.remove(PICKER_ITEM_ACTIVE_CLASS);\n        item.part.remove(PICKER_ITEM_ACTIVE_PART);\n      }\n    };\n    /**\n     * When ionInputModeChange is emitted, each column\n     * needs to check if it is the one being made available\n     * for text entry.\n     */\n    this.inputModeChange = (ev) => {\n      if (!this.numericInput) {\n        return;\n      }\n      const { useInputMode, inputModeColumn } = ev.detail;\n      /**\n       * If inputModeColumn is undefined then this means\n       * all numericInput columns are being selected.\n       */\n      const isColumnActive = inputModeColumn === undefined || inputModeColumn === this.el;\n      if (!useInputMode || !isColumnActive) {\n        this.setInputModeActive(false);\n        return;\n      }\n      this.setInputModeActive(true);\n    };\n    /**\n     * Setting isActive will cause a re-render.\n     * As a result, we do not want to cause the\n     * re-render mid scroll as this will cause\n     * the picker column to jump back to\n     * whatever value was selected at the\n     * start of the scroll interaction.\n     */\n    this.setInputModeActive = (state) => {\n      if (this.isScrolling) {\n        this.scrollEndCallback = () => {\n          this.isActive = state;\n        };\n        return;\n      }\n      this.isActive = state;\n    };\n    /**\n     * When the column scrolls, the component\n     * needs to determine which item is centered\n     * in the view and will emit an ionChange with\n     * the item object.\n     */\n    this.initializeScrollListener = () => {\n      /**\n       * The haptics for the wheel picker are\n       * an iOS-only feature. As a result, they should\n       * be disabled on Android.\n       */\n      const enableHaptics = isPlatform('ios');\n      const { el } = this;\n      let timeout;\n      let activeEl = this.activeItem;\n      const scrollCallback = () => {\n        raf(() => {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n          }\n          if (!this.isScrolling) {\n            enableHaptics && hapticSelectionStart();\n            this.isScrolling = true;\n          }\n          /**\n           * Select item in the center of the column\n           * which is the month/year that we want to select\n           */\n          const bbox = el.getBoundingClientRect();\n          const centerX = bbox.x + bbox.width / 2;\n          const centerY = bbox.y + bbox.height / 2;\n          const activeElement = el.shadowRoot.elementFromPoint(centerX, centerY);\n          if (activeEl !== null) {\n            this.setPickerItemActiveState(activeEl, false);\n          }\n          if (activeElement === null || activeElement.disabled) {\n            return;\n          }\n          /**\n           * If we are selecting a new value,\n           * we need to run haptics again.\n           */\n          if (activeElement !== activeEl) {\n            enableHaptics && hapticSelectionChanged();\n            if (this.canExitInputMode) {\n              /**\n               * The native iOS wheel picker\n               * only dismisses the keyboard\n               * once the selected item has changed\n               * as a result of a swipe\n               * from the user. If `canExitInputMode` is\n               * `false` then this means that the\n               * scroll is happening as a result of\n               * the `value` property programmatically changing\n               * either by an application or by the user via the keyboard.\n               */\n              this.exitInputMode();\n            }\n          }\n          activeEl = activeElement;\n          this.setPickerItemActiveState(activeElement, true);\n          timeout = setTimeout(() => {\n            this.isScrolling = false;\n            enableHaptics && hapticSelectionEnd();\n            /**\n             * Certain tasks (such as those that\n             * cause re-renders) should only be done\n             * once scrolling has finished, otherwise\n             * flickering may occur.\n             */\n            const { scrollEndCallback } = this;\n            if (scrollEndCallback) {\n              scrollEndCallback();\n              this.scrollEndCallback = undefined;\n            }\n            /**\n             * Reset this flag as the\n             * next scroll interaction could\n             * be a scroll from the user. In this\n             * case, we should exit input mode.\n             */\n            this.canExitInputMode = true;\n            const dataIndex = activeElement.getAttribute('data-index');\n            /**\n             * If no value it is\n             * possible we hit one of the\n             * empty padding columns.\n             */\n            if (dataIndex === null) {\n              return;\n            }\n            const index = parseInt(dataIndex, 10);\n            const selectedItem = this.items[index];\n            if (selectedItem.value !== this.value) {\n              this.setValue(selectedItem.value);\n            }\n          }, 250);\n        });\n      };\n      /**\n       * Wrap this in an raf so that the scroll callback\n       * does not fire when component is initially shown.\n       */\n      raf(() => {\n        el.addEventListener('scroll', scrollCallback);\n        this.destroyScrollListener = () => {\n          el.removeEventListener('scroll', scrollCallback);\n        };\n      });\n    };\n    /**\n     * Tells the parent picker to\n     * exit text entry mode. This is only called\n     * when the selected item changes during scroll, so\n     * we know that the user likely wants to scroll\n     * instead of type.\n     */\n    this.exitInputMode = () => {\n      const { parentEl } = this;\n      if (parentEl == null)\n        return;\n      parentEl.exitInputMode();\n      /**\n       * setInputModeActive only takes\n       * effect once scrolling stops to avoid\n       * a component re-render while scrolling.\n       * However, we want the visual active\n       * indicator to go away immediately, so\n       * we call classList.remove here.\n       */\n      this.el.classList.remove('picker-column-active');\n    };\n    this.isActive = false;\n    this.items = [];\n    this.value = undefined;\n    this.color = 'primary';\n    this.numericInput = false;\n  }\n  valueChange() {\n    if (this.isColumnVisible) {\n      /**\n       * Only scroll the active item into view when the picker column\n       * is actively visible to the user.\n       */\n      this.scrollActiveItemIntoView();\n    }\n  }\n  /**\n   * Only setup scroll listeners\n   * when the picker is visible, otherwise\n   * the container will have a scroll\n   * height of 0px.\n   */\n  componentWillLoad() {\n    const visibleCallback = (entries) => {\n      const ev = entries[0];\n      if (ev.isIntersecting) {\n        const { activeItem, el } = this;\n        this.isColumnVisible = true;\n        /**\n         * Because this initial call to scrollActiveItemIntoView has to fire before\n         * the scroll listener is set up, we need to manage the active class manually.\n         */\n        const oldActive = getElementRoot(el).querySelector(`.${PICKER_ITEM_ACTIVE_CLASS}`);\n        if (oldActive) {\n          this.setPickerItemActiveState(oldActive, false);\n        }\n        this.scrollActiveItemIntoView();\n        if (activeItem) {\n          this.setPickerItemActiveState(activeItem, true);\n        }\n        this.initializeScrollListener();\n      }\n      else {\n        this.isColumnVisible = false;\n        if (this.destroyScrollListener) {\n          this.destroyScrollListener();\n          this.destroyScrollListener = undefined;\n        }\n      }\n    };\n    new IntersectionObserver(visibleCallback, { threshold: 0.001 }).observe(this.el);\n    const parentEl = (this.parentEl = this.el.closest('ion-picker-internal'));\n    if (parentEl !== null) {\n      // TODO(FW-2832): type\n      parentEl.addEventListener('ionInputModeChange', (ev) => this.inputModeChange(ev));\n    }\n  }\n  componentDidRender() {\n    var _a;\n    const { activeItem, items, isColumnVisible, value } = this;\n    if (isColumnVisible) {\n      if (activeItem) {\n        this.scrollActiveItemIntoView();\n      }\n      else if (((_a = items[0]) === null || _a === void 0 ? void 0 : _a.value) !== value) {\n        /**\n         * If the picker column does not have an active item and the current value\n         * does not match the first item in the picker column, that means\n         * the value is out of bounds. In this case, we assign the value to the\n         * first item to match the scroll position of the column.\n         *\n         */\n        this.setValue(items[0].value);\n      }\n    }\n  }\n  /** @internal  */\n  async scrollActiveItemIntoView() {\n    const activeEl = this.activeItem;\n    if (activeEl) {\n      this.centerPickerItemInView(activeEl, false, false);\n    }\n  }\n  /**\n   * Sets the value prop and fires the ionChange event.\n   * This is used when we need to fire ionChange from\n   * user-generated events that cannot be caught with normal\n   * input/change event listeners.\n   * @internal\n   */\n  async setValue(value) {\n    const { items } = this;\n    this.value = value;\n    const findItem = items.find((item) => item.value === value && item.disabled !== true);\n    if (findItem) {\n      this.ionChange.emit(findItem);\n    }\n  }\n  get activeItem() {\n    return getElementRoot(this.el).querySelector(`.picker-item[data-value=\"${this.value}\"]:not([disabled])`);\n  }\n  render() {\n    const { items, color, isActive, numericInput } = this;\n    const mode = getIonMode(this);\n    /**\n     * exportparts is needed so ion-datetime can expose the parts\n     * from two layers of shadow nesting. If this causes problems,\n     * the attribute can be moved to datetime.tsx and set on every\n     * instance of ion-picker-column-internal there instead.\n     */\n    return (h(Host, { exportparts: `${PICKER_ITEM_PART}, ${PICKER_ITEM_ACTIVE_PART}`, tabindex: 0, class: createColorClasses(color, {\n        [mode]: true,\n        ['picker-column-active']: isActive,\n        ['picker-column-numeric-input']: numericInput,\n      }) }, h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), items.map((item, index) => {\n      {\n        /*\n        Users should be able to tab\n        between multiple columns. As a result,\n        we set tabindex here so that tabbing switches\n        between columns instead of buttons. Users\n        can still use arrow keys on the keyboard to\n        navigate the column up and down.\n      */\n      }\n      return (h(\"button\", { tabindex: \"-1\", class: {\n          'picker-item': true,\n          'picker-item-disabled': item.disabled || false,\n        }, \"data-value\": item.value, \"data-index\": index, onClick: (ev) => {\n          this.centerPickerItemInView(ev.target, true);\n        }, disabled: item.disabled, part: PICKER_ITEM_PART }, item.text));\n    }), h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\"), h(\"div\", { class: \"picker-item picker-item-empty\", \"aria-hidden\": \"true\" }, \"\\u00A0\")));\n  }\n  static get is() { return \"ion-picker-column-internal\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"picker-column-internal.ios.scss\"],\n      \"md\": [\"picker-column-internal.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"picker-column-internal.ios.css\"],\n      \"md\": [\"picker-column-internal.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"items\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"PickerColumnItem[]\",\n          \"resolved\": \"PickerColumnItem[]\",\n          \"references\": {\n            \"PickerColumnItem\": {\n              \"location\": \"import\",\n              \"path\": \"./picker-column-internal-interfaces\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A list of options to be displayed in the picker\"\n        },\n        \"defaultValue\": \"[]\"\n      },\n      \"value\": {\n        \"type\": \"any\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"string | number\",\n          \"resolved\": \"number | string | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The selected option in the picker.\"\n        },\n        \"attribute\": \"value\",\n        \"reflect\": false\n      },\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true,\n        \"defaultValue\": \"'primary'\"\n      },\n      \"numericInput\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"If `true`, tapping the picker will\\nreveal a number input keyboard that lets\\nthe user type in values for each picker\\ncolumn. This is useful when working\\nwith time pickers.\"\n        },\n        \"attribute\": \"numeric-input\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"isActive\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionChange\",\n        \"name\": \"ionChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the value has changed.\"\n        },\n        \"complexType\": {\n          \"original\": \"PickerColumnItem\",\n          \"resolved\": \"PickerColumnItem\",\n          \"references\": {\n            \"PickerColumnItem\": {\n              \"location\": \"import\",\n              \"path\": \"./picker-column-internal-interfaces\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"scrollActiveItemIntoView\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"setValue\": {\n        \"complexType\": {\n          \"signature\": \"(value?: string | number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Sets the value prop and fires the ionChange event.\\nThis is used when we need to fire ionChange from\\nuser-generated events that cannot be caught with normal\\ninput/change event listeners.\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"value\",\n        \"methodName\": \"valueChange\"\n      }];\n  }\n}\nconst PICKER_ITEM_ACTIVE_CLASS = 'picker-item-active';\nconst PICKER_ITEM_PART = 'wheel-item';\nconst PICKER_ITEM_ACTIVE_PART = 'active';\n",":host {\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 200px;\n  /**\n   * Picker columns should display\n   * in the order in which developers\n   * added them and should ignore\n   * LTR vs RTL directions.\n   */\n  direction: ltr;\n  /**\n   * This is required otherwise the\n   * highlight will appear behind\n   * the picker when used inline.\n   */\n  z-index: 0;\n}\n\n:host .picker-before,\n:host .picker-after {\n  position: absolute;\n  width: 100%;\n  /**\n   * The transform and z-index\n   * are needed for WebKit otherwise\n   * the fade will appear underneath the picker.\n   */\n  transform: translateZ(0);\n  z-index: 1;\n  pointer-events: none;\n}\n\n:host .picker-before {\n  top: 0;\n  height: 83px;\n}\n@supports (inset-inline-start: 0) {\n  :host .picker-before {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host .picker-before {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .picker-before {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host .picker-before:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host .picker-after {\n  top: 116px;\n  height: 84px;\n}\n@supports (inset-inline-start: 0) {\n  :host .picker-after {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host .picker-after {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .picker-after {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host .picker-after:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host .picker-highlight {\n  border-radius: 8px;\n  left: 0;\n  right: 0;\n  top: 50%;\n  bottom: 0;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  position: absolute;\n  width: calc(100% - 16px);\n  height: 34px;\n  transform: translateY(-50%);\n  background: var(--wheel-highlight-background);\n  z-index: -1;\n}\n\n:host input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  clip: rect(0 0 0 0);\n  opacity: 0;\n  overflow: hidden;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n\n:host ::slotted(ion-picker-column-internal:first-of-type) {\n  text-align: start;\n}\n\n:host ::slotted(ion-picker-column-internal:last-of-type) {\n  text-align: end;\n}\n\n:host ::slotted(ion-picker-column-internal:only-child) {\n  text-align: center;\n}\n\n:host .picker-before {\n  background: linear-gradient(to bottom, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0.8) 100%);\n}\n\n:host .picker-after {\n  background: linear-gradient(to top, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0.8) 100%);\n}\n\n:host .picker-highlight {\n  background: var(--wheel-highlight-background, var(--ion-color-step-150, #eeeeef));\n}",":host {\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 200px;\n  /**\n   * Picker columns should display\n   * in the order in which developers\n   * added them and should ignore\n   * LTR vs RTL directions.\n   */\n  direction: ltr;\n  /**\n   * This is required otherwise the\n   * highlight will appear behind\n   * the picker when used inline.\n   */\n  z-index: 0;\n}\n\n:host .picker-before,\n:host .picker-after {\n  position: absolute;\n  width: 100%;\n  /**\n   * The transform and z-index\n   * are needed for WebKit otherwise\n   * the fade will appear underneath the picker.\n   */\n  transform: translateZ(0);\n  z-index: 1;\n  pointer-events: none;\n}\n\n:host .picker-before {\n  top: 0;\n  height: 83px;\n}\n@supports (inset-inline-start: 0) {\n  :host .picker-before {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host .picker-before {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .picker-before {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host .picker-before:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host .picker-after {\n  top: 116px;\n  height: 84px;\n}\n@supports (inset-inline-start: 0) {\n  :host .picker-after {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  :host .picker-after {\n    left: 0;\n  }\n  :host-context([dir=rtl]) .picker-after {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n  @supports selector(:dir(rtl)) {\n    :host .picker-after:dir(rtl) {\n      left: unset;\n      right: unset;\n      right: 0;\n    }\n  }\n}\n\n:host .picker-highlight {\n  border-radius: 8px;\n  left: 0;\n  right: 0;\n  top: 50%;\n  bottom: 0;\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  position: absolute;\n  width: calc(100% - 16px);\n  height: 34px;\n  transform: translateY(-50%);\n  background: var(--wheel-highlight-background);\n  z-index: -1;\n}\n\n:host input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  clip: rect(0 0 0 0);\n  opacity: 0;\n  overflow: hidden;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n\n:host ::slotted(ion-picker-column-internal:first-of-type) {\n  text-align: start;\n}\n\n:host ::slotted(ion-picker-column-internal:last-of-type) {\n  text-align: end;\n}\n\n:host ::slotted(ion-picker-column-internal:only-child) {\n  text-align: center;\n}\n\n:host .picker-before {\n  background: linear-gradient(to bottom, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 20%, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0) 90%);\n}\n\n:host .picker-after {\n  background: linear-gradient(to top, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 1) 30%, rgba(var(--wheel-fade-background-rgb, var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255))), 0) 90%);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getElementRoot } from \"../../utils/helpers\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n * @internal\n */\nexport class PickerInternal {\n  constructor() {\n    this.useInputMode = false;\n    this.isInHighlightBounds = (ev) => {\n      const { highlightEl } = this;\n      if (!highlightEl) {\n        return false;\n      }\n      const bbox = highlightEl.getBoundingClientRect();\n      /**\n       * Check to see if the user clicked\n       * outside the bounds of the highlight.\n       */\n      const outsideX = ev.clientX < bbox.left || ev.clientX > bbox.right;\n      const outsideY = ev.clientY < bbox.top || ev.clientY > bbox.bottom;\n      if (outsideX || outsideY) {\n        return false;\n      }\n      return true;\n    };\n    /**\n     * If we are no longer focused\n     * on a picker column, then we should\n     * exit input mode. An exception is made\n     * for the input in the picker since having\n     * that focused means we are still in input mode.\n     */\n    this.onFocusOut = (ev) => {\n      // TODO(FW-2832): type\n      const { relatedTarget } = ev;\n      if (!relatedTarget || (relatedTarget.tagName !== 'ION-PICKER-COLUMN-INTERNAL' && relatedTarget !== this.inputEl)) {\n        this.exitInputMode();\n      }\n    };\n    /**\n     * When picker columns receive focus\n     * the parent picker needs to determine\n     * whether to enter/exit input mode.\n     */\n    this.onFocusIn = (ev) => {\n      // TODO(FW-2832): type\n      const { target } = ev;\n      /**\n       * Due to browser differences in how/when focus\n       * is dispatched on certain elements, we need to\n       * make sure that this function only ever runs when\n       * focusing a picker column.\n       */\n      if (target.tagName !== 'ION-PICKER-COLUMN-INTERNAL') {\n        return;\n      }\n      /**\n       * If we have actionOnClick\n       * then this means the user focused\n       * a picker column via mouse or\n       * touch (i.e. a PointerEvent). As a result,\n       * we should not enter/exit input mode\n       * until the click event has fired, which happens\n       * after the `focusin` event.\n       *\n       * Otherwise, the user likely focused\n       * the column using their keyboard and\n       * we should enter/exit input mode automatically.\n       */\n      if (!this.actionOnClick) {\n        const columnEl = target;\n        const allowInput = columnEl.numericInput;\n        if (allowInput) {\n          this.enterInputMode(columnEl, false);\n        }\n        else {\n          this.exitInputMode();\n        }\n      }\n    };\n    /**\n     * On click we need to run an actionOnClick\n     * function that has been set in onPointerDown\n     * so that we enter/exit input mode correctly.\n     */\n    this.onClick = () => {\n      const { actionOnClick } = this;\n      if (actionOnClick) {\n        actionOnClick();\n        this.actionOnClick = undefined;\n      }\n    };\n    /**\n     * Clicking a column also focuses the column on\n     * certain browsers, so we use onPointerDown\n     * to tell the onFocusIn function that users\n     * are trying to click the column rather than\n     * focus the column using the keyboard. When the\n     * user completes the click, the onClick function\n     * runs and runs the actionOnClick callback.\n     */\n    this.onPointerDown = (ev) => {\n      const { useInputMode, inputModeColumn, el } = this;\n      if (this.isInHighlightBounds(ev)) {\n        /**\n         * If we were already in\n         * input mode, then we should determine\n         * if we tapped a particular column and\n         * should switch to input mode for\n         * that specific column.\n         */\n        if (useInputMode) {\n          /**\n           * If we tapped a picker column\n           * then we should either switch to input\n           * mode for that column or all columns.\n           * Otherwise we should exit input mode\n           * since we just tapped the highlight and\n           * not a column.\n           */\n          if (ev.target.tagName === 'ION-PICKER-COLUMN-INTERNAL') {\n            /**\n             * If user taps 2 different columns\n             * then we should just switch to input mode\n             * for the new column rather than switching to\n             * input mode for all columns.\n             */\n            if (inputModeColumn && inputModeColumn === ev.target) {\n              this.actionOnClick = () => {\n                this.enterInputMode();\n              };\n            }\n            else {\n              this.actionOnClick = () => {\n                this.enterInputMode(ev.target);\n              };\n            }\n          }\n          else {\n            this.actionOnClick = () => {\n              this.exitInputMode();\n            };\n          }\n          /**\n           * If we were not already in\n           * input mode, then we should\n           * enter input mode for all columns.\n           */\n        }\n        else {\n          /**\n           * If there is only 1 numeric input column\n           * then we should skip multi column input.\n           */\n          const columns = el.querySelectorAll('ion-picker-column-internal.picker-column-numeric-input');\n          const columnEl = columns.length === 1 ? ev.target : undefined;\n          this.actionOnClick = () => {\n            this.enterInputMode(columnEl);\n          };\n        }\n        return;\n      }\n      this.actionOnClick = () => {\n        this.exitInputMode();\n      };\n    };\n    /**\n     * Enters input mode to allow\n     * for text entry of numeric values.\n     * If on mobile, we focus a hidden input\n     * field so that the on screen keyboard\n     * is brought up. When tabbing using a\n     * keyboard, picker columns receive an outline\n     * to indicate they are focused. As a result,\n     * we should not focus the hidden input as it\n     * would cause the outline to go away, preventing\n     * users from having any visual indication of which\n     * column is focused.\n     */\n    this.enterInputMode = (columnEl, focusInput = true) => {\n      const { inputEl, el } = this;\n      if (!inputEl) {\n        return;\n      }\n      /**\n       * Only active input mode if there is at\n       * least one column that accepts numeric input.\n       */\n      const hasInputColumn = el.querySelector('ion-picker-column-internal.picker-column-numeric-input');\n      if (!hasInputColumn) {\n        return;\n      }\n      /**\n       * If columnEl is undefined then\n       * it is assumed that all numeric pickers\n       * are eligible for text entry.\n       * (i.e. hour and minute columns)\n       */\n      this.useInputMode = true;\n      this.inputModeColumn = columnEl;\n      /**\n       * Users with a keyboard and mouse can\n       * activate input mode where the input is\n       * focused as well as when it is not focused,\n       * so we need to make sure we clean up any\n       * old listeners.\n       */\n      if (focusInput) {\n        if (this.destroyKeypressListener) {\n          this.destroyKeypressListener();\n          this.destroyKeypressListener = undefined;\n        }\n        inputEl.focus();\n      }\n      else {\n        el.addEventListener('keypress', this.onKeyPress);\n        this.destroyKeypressListener = () => {\n          el.removeEventListener('keypress', this.onKeyPress);\n        };\n      }\n      this.emitInputModeChange();\n    };\n    this.onKeyPress = (ev) => {\n      const { inputEl } = this;\n      if (!inputEl) {\n        return;\n      }\n      const parsedValue = parseInt(ev.key, 10);\n      /**\n       * Only numbers should be allowed\n       */\n      if (!Number.isNaN(parsedValue)) {\n        inputEl.value += ev.key;\n        this.onInputChange();\n      }\n    };\n    this.selectSingleColumn = () => {\n      const { inputEl, inputModeColumn, singleColumnSearchTimeout } = this;\n      if (!inputEl || !inputModeColumn) {\n        return;\n      }\n      const values = inputModeColumn.items.filter((item) => item.disabled !== true);\n      /**\n       * If users pause for a bit, the search\n       * value should be reset similar to how a\n       * <select> behaves. So typing \"34\", waiting,\n       * then typing \"5\" should select \"05\".\n       */\n      if (singleColumnSearchTimeout) {\n        clearTimeout(singleColumnSearchTimeout);\n      }\n      this.singleColumnSearchTimeout = setTimeout(() => {\n        inputEl.value = '';\n        this.singleColumnSearchTimeout = undefined;\n      }, 1000);\n      /**\n       * For values that are longer than 2 digits long\n       * we should shift the value over 1 character\n       * to the left. So typing \"456\" would result in \"56\".\n       * TODO: If we want to support more than just\n       * time entry, we should update this value to be\n       * the max length of all of the picker items.\n       */\n      if (inputEl.value.length >= 3) {\n        const startIndex = inputEl.value.length - 2;\n        const newString = inputEl.value.substring(startIndex);\n        inputEl.value = newString;\n        this.selectSingleColumn();\n        return;\n      }\n      /**\n       * Checking the value of the input gets priority\n       * first. For example, if the value of the input\n       * is \"1\" and we entered \"2\", then the complete value\n       * is \"12\" and we should select hour 12.\n       *\n       * Regex removes any leading zeros from values like \"02\",\n       * but it keeps a single zero if there are only zeros in the string.\n       * 0+(?=[1-9]) --> Match 1 or more zeros that are followed by 1-9\n       * 0+(?=0$) --> Match 1 or more zeros that must be followed by one 0 and end.\n       */\n      const findItemFromCompleteValue = values.find(({ text }) => {\n        const parsedText = text.replace(/^0+(?=[1-9])|0+(?=0$)/, '');\n        return parsedText === inputEl.value;\n      });\n      if (findItemFromCompleteValue) {\n        inputModeColumn.setValue(findItemFromCompleteValue.value);\n        return;\n      }\n      /**\n       * If we typed \"56\" to get minute 56, then typed \"7\",\n       * we should select \"07\" as \"567\" is not a valid minute.\n       */\n      if (inputEl.value.length === 2) {\n        const changedCharacter = inputEl.value.substring(inputEl.value.length - 1);\n        inputEl.value = changedCharacter;\n        this.selectSingleColumn();\n      }\n    };\n    /**\n     * Searches a list of column items for a particular\n     * value. This is currently used for numeric values.\n     * The zeroBehavior can be set to account for leading\n     * or trailing zeros when looking at the item text.\n     */\n    this.searchColumn = (colEl, value, zeroBehavior = 'start') => {\n      const behavior = zeroBehavior === 'start' ? /^0+/ : /0$/;\n      const item = colEl.items.find(({ text, disabled }) => disabled !== true && text.replace(behavior, '') === value);\n      if (item) {\n        colEl.setValue(item.value);\n      }\n    };\n    this.selectMultiColumn = () => {\n      const { inputEl, el } = this;\n      if (!inputEl) {\n        return;\n      }\n      const numericPickers = Array.from(el.querySelectorAll('ion-picker-column-internal')).filter((col) => col.numericInput);\n      const firstColumn = numericPickers[0];\n      const lastColumn = numericPickers[1];\n      let value = inputEl.value;\n      let minuteValue;\n      switch (value.length) {\n        case 1:\n          this.searchColumn(firstColumn, value);\n          break;\n        case 2:\n          /**\n           * If the first character is `0` or `1` it is\n           * possible that users are trying to type `09`\n           * or `11` into the hour field, so we should look\n           * at that first.\n           */\n          const firstCharacter = inputEl.value.substring(0, 1);\n          value = firstCharacter === '0' || firstCharacter === '1' ? inputEl.value : firstCharacter;\n          this.searchColumn(firstColumn, value);\n          /**\n           * If only checked the first value,\n           * we can check the second value\n           * for a match in the minutes column\n           */\n          if (value.length === 1) {\n            minuteValue = inputEl.value.substring(inputEl.value.length - 1);\n            this.searchColumn(lastColumn, minuteValue, 'end');\n          }\n          break;\n        case 3:\n          /**\n           * If the first character is `0` or `1` it is\n           * possible that users are trying to type `09`\n           * or `11` into the hour field, so we should look\n           * at that first.\n           */\n          const firstCharacterAgain = inputEl.value.substring(0, 1);\n          value =\n            firstCharacterAgain === '0' || firstCharacterAgain === '1'\n              ? inputEl.value.substring(0, 2)\n              : firstCharacterAgain;\n          this.searchColumn(firstColumn, value);\n          /**\n           * If only checked the first value,\n           * we can check the second value\n           * for a match in the minutes column\n           */\n          minuteValue = value.length === 1 ? inputEl.value.substring(1) : inputEl.value.substring(2);\n          this.searchColumn(lastColumn, minuteValue, 'end');\n          break;\n        case 4:\n          /**\n           * If the first character is `0` or `1` it is\n           * possible that users are trying to type `09`\n           * or `11` into the hour field, so we should look\n           * at that first.\n           */\n          const firstCharacterAgainAgain = inputEl.value.substring(0, 1);\n          value =\n            firstCharacterAgainAgain === '0' || firstCharacterAgainAgain === '1'\n              ? inputEl.value.substring(0, 2)\n              : firstCharacterAgainAgain;\n          this.searchColumn(firstColumn, value);\n          /**\n           * If only checked the first value,\n           * we can check the second value\n           * for a match in the minutes column\n           */\n          const minuteValueAgain = value.length === 1\n            ? inputEl.value.substring(1, inputEl.value.length)\n            : inputEl.value.substring(2, inputEl.value.length);\n          this.searchColumn(lastColumn, minuteValueAgain, 'end');\n          break;\n        default:\n          const startIndex = inputEl.value.length - 4;\n          const newString = inputEl.value.substring(startIndex);\n          inputEl.value = newString;\n          this.selectMultiColumn();\n          break;\n      }\n    };\n    /**\n     * Searches the value of the active column\n     * to determine which value users are trying\n     * to select\n     */\n    this.onInputChange = () => {\n      const { useInputMode, inputEl, inputModeColumn } = this;\n      if (!useInputMode || !inputEl) {\n        return;\n      }\n      if (inputModeColumn) {\n        this.selectSingleColumn();\n      }\n      else {\n        this.selectMultiColumn();\n      }\n    };\n    /**\n     * Emit ionInputModeChange. Picker columns\n     * listen for this event to determine whether\n     * or not their column is \"active\" for text input.\n     */\n    this.emitInputModeChange = () => {\n      const { useInputMode, inputModeColumn } = this;\n      this.ionInputModeChange.emit({\n        useInputMode,\n        inputModeColumn,\n      });\n    };\n  }\n  /**\n   * When the picker is interacted with\n   * we need to prevent touchstart so other\n   * gestures do not fire. For example,\n   * scrolling on the wheel picker\n   * in ion-datetime should not cause\n   * a card modal to swipe to close.\n   */\n  preventTouchStartPropagation(ev) {\n    ev.stopPropagation();\n  }\n  componentWillLoad() {\n    getElementRoot(this.el).addEventListener('focusin', this.onFocusIn);\n    getElementRoot(this.el).addEventListener('focusout', this.onFocusOut);\n  }\n  /**\n   * @internal\n   * Exits text entry mode for the picker\n   * This method blurs the hidden input\n   * and cause the keyboard to dismiss.\n   */\n  async exitInputMode() {\n    const { inputEl, useInputMode } = this;\n    if (!useInputMode || !inputEl) {\n      return;\n    }\n    this.useInputMode = false;\n    this.inputModeColumn = undefined;\n    inputEl.blur();\n    inputEl.value = '';\n    if (this.destroyKeypressListener) {\n      this.destroyKeypressListener();\n      this.destroyKeypressListener = undefined;\n    }\n    this.emitInputModeChange();\n  }\n  render() {\n    return (h(Host, { onPointerDown: (ev) => this.onPointerDown(ev), onClick: () => this.onClick() }, h(\"input\", { \"aria-hidden\": \"true\", tabindex: -1, inputmode: \"numeric\", type: \"number\", ref: (el) => (this.inputEl = el), onInput: () => this.onInputChange(), onBlur: () => this.exitInputMode() }), h(\"div\", { class: \"picker-before\" }), h(\"div\", { class: \"picker-after\" }), h(\"div\", { class: \"picker-highlight\", ref: (el) => (this.highlightEl = el) }), h(\"slot\", null)));\n  }\n  static get is() { return \"ion-picker-internal\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"picker-internal.ios.scss\"],\n      \"md\": [\"picker-internal.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"picker-internal.ios.css\"],\n      \"md\": [\"picker-internal.md.css\"]\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionInputModeChange\",\n        \"name\": \"ionInputModeChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"\"\n        },\n        \"complexType\": {\n          \"original\": \"PickerInternalChangeEventDetail\",\n          \"resolved\": \"PickerInternalChangeEventDetail\",\n          \"references\": {\n            \"PickerInternalChangeEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./picker-internal-interfaces\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"exitInputMode\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": \"Exits text entry mode for the picker\\nThis method blurs the hidden input\\nand cause the keyboard to dismiss.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get listeners() {\n    return [{\n        \"name\": \"touchstart\",\n        \"method\": \"preventTouchStartPropagation\",\n        \"target\": undefined,\n        \"capture\": false,\n        \"passive\": true\n      }];\n  }\n}\n"],"mappings":"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"}