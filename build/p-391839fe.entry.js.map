{"version":3,"names":["VIEW_STATE_NEW","VIEW_STATE_ATTACHED","VIEW_STATE_DESTROYED","ViewController","constructor","component","params","this","state","init","container","element","attachComponent","delegate","_destroy","assert","removeViewFromDom","parentElement","remove","nav","undefined","matches","view","id","shallowEqualStringMap","convertToView","page","convertToViews","pages","map","componentProps","filter","v","navCss","Nav","hostRef","transInstr","gestureOrAnimationInProgress","useRouter","isTransitioning","destroyed","views","didLoad","swipeGesture","animated","animation","rootParams","root","swipeGestureChanged","gesture","enable","rootChanged","setRoot","componentWillLoad","document","querySelector","el","closest","mode","getIonMode","config","getBoolean","ionNavWillLoad","emit","componentDidLoad","import","createSwipeBackGesture","canStart","bind","onStart","onMove","onEnd","connectedCallback","disconnectedCallback","lifecycle","LIFECYCLE_WILL_UNLOAD","destroy","length","push","opts","done","insert","insertIndex","insertPages","insertComponents","queueTrns","insertStart","insertViews","pop","removeIndex","popTo","indexOrViewCtrl","ti","removeStart","removeCount","removeView","popToRoot","startIndex","setPages","setRouteId","direction","active","getActiveSync","Promise","resolve","changed","promise","r","finish","commonOpts","updateURL","viewIsReady","enteringEl","mark","p","markVisible","async","viewController","find","Object","assign","animationBuilder","getRouteId","tagName","getActive","getByIndex","index","canGoBack","canGoBackSync","getPrevious","getPreviousSync","getLength","indexOf","_a","_b","skipIfBusy","reject","router","canTransition","nextTrns","success","result","fireError","hasCompleted","requiresTransition","enteringView","leavingView","navChanged","failed","rejectReason","shift","runTransition","ionNavWillChange","prepareTI","getEnteringView","Error","postViewInit","enteringRequiresTransition","leavingRequiresTransition","isBackDirection","transition","ionNavDidChange","_c","viewsLength","viewControllers","removeEnd","i","destroyQueue","finalNumViews","console","warn","insertViewAt","LIFECYCLE_WILL_LEAVE","LIFECYCLE_DID_LEAVE","destroyView","progressCallback","progressAnimation","ani","onFinish","oneTimeCallback","progressEnd","sbAni","leavingEl","animationOpts","showGoBack","baseEl","get","transitionFinish","activeView","unmountInactiveViews","existingIndex","splice","activeViewIndex","setPageHidden","stepValue","progressStep","shouldComplete","dur","newStepValue","easing","getTimeGivenProgression","render","h"],"sources":["node_modules/@ionic/core/dist/collection/components/nav/view-controller.js","node_modules/@ionic/core/dist/collection/components/nav/nav.css?tag=ion-nav&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/nav/nav.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { attachComponent } from \"../../utils/framework-delegate\";\nimport { assert, shallowEqualStringMap } from \"../../utils/helpers\";\nexport const VIEW_STATE_NEW = 1;\nexport const VIEW_STATE_ATTACHED = 2;\nexport const VIEW_STATE_DESTROYED = 3;\n// TODO(FW-2832): types\nexport class ViewController {\n  constructor(component, params) {\n    this.component = component;\n    this.params = params;\n    this.state = VIEW_STATE_NEW;\n  }\n  async init(container) {\n    this.state = VIEW_STATE_ATTACHED;\n    if (!this.element) {\n      const component = this.component;\n      this.element = await attachComponent(this.delegate, container, component, ['ion-page', 'ion-page-invisible'], this.params);\n    }\n  }\n  /**\n   * DOM WRITE\n   */\n  _destroy() {\n    assert(this.state !== VIEW_STATE_DESTROYED, 'view state must be ATTACHED');\n    const element = this.element;\n    if (element) {\n      if (this.delegate) {\n        this.delegate.removeViewFromDom(element.parentElement, element);\n      }\n      else {\n        element.remove();\n      }\n    }\n    this.nav = undefined;\n    this.state = VIEW_STATE_DESTROYED;\n  }\n}\nexport const matches = (view, id, params) => {\n  if (!view) {\n    return false;\n  }\n  if (view.component !== id) {\n    return false;\n  }\n  return shallowEqualStringMap(view.params, params);\n};\nexport const convertToView = (page, params) => {\n  if (!page) {\n    return null;\n  }\n  if (page instanceof ViewController) {\n    return page;\n  }\n  return new ViewController(page, params);\n};\nexport const convertToViews = (pages) => {\n  return pages\n    .map((page) => {\n    if (page instanceof ViewController) {\n      return page;\n    }\n    if ('component' in page) {\n      return convertToView(page.component, page.componentProps === null ? undefined : page.componentProps);\n    }\n    return convertToView(page, undefined);\n  })\n    .filter((v) => v !== null);\n};\n",":host {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  contain: layout size style;\n  overflow: hidden;\n  z-index: 0;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Build, h } from '@stencil/core';\nimport { getTimeGivenProgression } from \"../../utils/animation/cubic-bezier\";\nimport { assert } from \"../../utils/helpers\";\nimport { printIonWarning } from \"../../utils/logging/index\";\nimport { lifecycle, setPageHidden, transition } from \"../../utils/transition/index\";\nimport { config } from '../../global/config';\nimport { getIonMode } from '../../global/ionic-global';\nimport { LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_LEAVE, LIFECYCLE_WILL_UNLOAD } from './constants';\nimport { VIEW_STATE_ATTACHED, VIEW_STATE_DESTROYED, VIEW_STATE_NEW, convertToViews, matches } from './view-controller';\nexport class Nav {\n  constructor() {\n    this.transInstr = [];\n    this.gestureOrAnimationInProgress = false;\n    this.useRouter = false;\n    this.isTransitioning = false;\n    this.destroyed = false;\n    this.views = [];\n    this.didLoad = false;\n    this.delegate = undefined;\n    this.swipeGesture = undefined;\n    this.animated = true;\n    this.animation = undefined;\n    this.rootParams = undefined;\n    this.root = undefined;\n  }\n  swipeGestureChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeGesture === true);\n    }\n  }\n  rootChanged() {\n    const isDev = Build.isDev;\n    if (this.root === undefined) {\n      return;\n    }\n    if (this.didLoad === false) {\n      /**\n       * If the component has not loaded yet, we can skip setting up the root component.\n       * It will be called when `componentDidLoad` fires.\n       */\n      return;\n    }\n    if (!this.useRouter) {\n      if (this.root !== undefined) {\n        this.setRoot(this.root, this.rootParams);\n      }\n    }\n    else if (isDev) {\n      printIonWarning('<ion-nav> does not support a root attribute when using ion-router.', this.el);\n    }\n  }\n  componentWillLoad() {\n    this.useRouter = document.querySelector('ion-router') !== null && this.el.closest('[no-router]') === null;\n    if (this.swipeGesture === undefined) {\n      const mode = getIonMode(this);\n      this.swipeGesture = config.getBoolean('swipeBackEnabled', mode === 'ios');\n    }\n    this.ionNavWillLoad.emit();\n  }\n  async componentDidLoad() {\n    // We want to set this flag before any watch callbacks are manually called\n    this.didLoad = true;\n    this.rootChanged();\n    this.gesture = (await import('../../utils/gesture/swipe-back')).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));\n    this.swipeGestureChanged();\n  }\n  connectedCallback() {\n    this.destroyed = false;\n  }\n  disconnectedCallback() {\n    for (const view of this.views) {\n      lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);\n      view._destroy();\n    }\n    // Release swipe back gesture and transition.\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n    this.transInstr.length = 0;\n    this.views.length = 0;\n    this.destroyed = true;\n  }\n  /**\n   * Push a new component onto the current navigation stack. Pass any additional\n   * information along as an object. This additional information is accessible\n   * through NavParams.\n   *\n   * @param component The component to push onto the navigation stack.\n   * @param componentProps Any properties of the component.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  push(component, componentProps, opts, done) {\n    return this.insert(-1, component, componentProps, opts, done);\n  }\n  /**\n   * Inserts a component into the navigation stack at the specified index.\n   * This is useful to add a component at any point in the navigation stack.\n   *\n   * @param insertIndex The index to insert the component at in the stack.\n   * @param component The component to insert into the navigation stack.\n   * @param componentProps Any properties of the component.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  insert(insertIndex, component, componentProps, opts, done) {\n    return this.insertPages(insertIndex, [{ component, componentProps }], opts, done);\n  }\n  /**\n   * Inserts an array of components into the navigation stack at the specified index.\n   * The last component in the array will become instantiated as a view, and animate\n   * in to become the active view.\n   *\n   * @param insertIndex The index to insert the components at in the stack.\n   * @param insertComponents The components to insert into the navigation stack.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  insertPages(insertIndex, insertComponents, opts, done) {\n    return this.queueTrns({\n      insertStart: insertIndex,\n      insertViews: insertComponents,\n      opts,\n    }, done);\n  }\n  /**\n   * Pop a component off of the navigation stack. Navigates back from the current\n   * component.\n   *\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  pop(opts, done) {\n    return this.removeIndex(-1, 1, opts, done);\n  }\n  /**\n   * Pop to a specific index in the navigation stack.\n   *\n   * @param indexOrViewCtrl The index or view controller to pop to.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  popTo(indexOrViewCtrl, opts, done) {\n    const ti = {\n      removeStart: -1,\n      removeCount: -1,\n      opts,\n    };\n    if (typeof indexOrViewCtrl === 'object' && indexOrViewCtrl.component) {\n      ti.removeView = indexOrViewCtrl;\n      ti.removeStart = 1;\n    }\n    else if (typeof indexOrViewCtrl === 'number') {\n      ti.removeStart = indexOrViewCtrl + 1;\n    }\n    return this.queueTrns(ti, done);\n  }\n  /**\n   * Navigate back to the root of the stack, no matter how far back that is.\n   *\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  popToRoot(opts, done) {\n    return this.removeIndex(1, -1, opts, done);\n  }\n  /**\n   * Removes a component from the navigation stack at the specified index.\n   *\n   * @param startIndex The number to begin removal at.\n   * @param removeCount The number of components to remove.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  removeIndex(startIndex, removeCount = 1, opts, done) {\n    return this.queueTrns({\n      removeStart: startIndex,\n      removeCount,\n      opts,\n    }, done);\n  }\n  /**\n   * Set the root for the current navigation stack to a component.\n   *\n   * @param component The component to set as the root of the navigation stack.\n   * @param componentProps Any properties of the component.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  setRoot(component, componentProps, opts, done) {\n    return this.setPages([{ component, componentProps }], opts, done);\n  }\n  /**\n   * Set the views of the current navigation stack and navigate to the last view.\n   * By default animations are disabled, but they can be enabled by passing options\n   * to the navigation controller. Navigation parameters can also be passed to the\n   * individual pages in the array.\n   *\n   * @param views The list of views to set as the navigation stack.\n   * @param opts The navigation options.\n   * @param done The transition complete function.\n   */\n  setPages(views, opts, done) {\n    opts !== null && opts !== void 0 ? opts : (opts = {});\n    // if animation wasn't set to true then default it to NOT animate\n    if (opts.animated !== true) {\n      opts.animated = false;\n    }\n    return this.queueTrns({\n      insertStart: 0,\n      insertViews: views,\n      removeStart: 0,\n      removeCount: -1,\n      opts,\n    }, done);\n  }\n  /**\n   * Called by the router to update the view.\n   *\n   * @param id The component tag.\n   * @param params The component params.\n   * @param direction A direction hint.\n   * @param animation an AnimationBuilder.\n   *\n   * @return the status.\n   * @internal\n   */\n  setRouteId(id, params, direction, animation) {\n    const active = this.getActiveSync();\n    if (matches(active, id, params)) {\n      return Promise.resolve({\n        changed: false,\n        element: active.element,\n      });\n    }\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    let finish;\n    const commonOpts = {\n      updateURL: false,\n      viewIsReady: (enteringEl) => {\n        let mark;\n        const p = new Promise((r) => (mark = r));\n        resolve({\n          changed: true,\n          element: enteringEl,\n          markVisible: async () => {\n            mark();\n            await finish;\n          },\n        });\n        return p;\n      },\n    };\n    if (direction === 'root') {\n      finish = this.setRoot(id, params, commonOpts);\n    }\n    else {\n      // Look for a view matching the target in the view stack.\n      const viewController = this.views.find((v) => matches(v, id, params));\n      if (viewController) {\n        finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animationBuilder: animation }));\n      }\n      else if (direction === 'forward') {\n        finish = this.push(id, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation }));\n      }\n      else if (direction === 'back') {\n        finish = this.setRoot(id, params, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animated: true, animationBuilder: animation }));\n      }\n    }\n    return promise;\n  }\n  /**\n   * Called by <ion-router> to retrieve the current component.\n   *\n   * @internal\n   */\n  async getRouteId() {\n    const active = this.getActiveSync();\n    if (active) {\n      return {\n        id: active.element.tagName,\n        params: active.params,\n        element: active.element,\n      };\n    }\n    return undefined;\n  }\n  /**\n   * Get the active view.\n   */\n  async getActive() {\n    return this.getActiveSync();\n  }\n  /**\n   * Get the view at the specified index.\n   *\n   * @param index The index of the view.\n   */\n  async getByIndex(index) {\n    return this.views[index];\n  }\n  /**\n   * Returns `true` if the current view can go back.\n   *\n   * @param view The view to check.\n   */\n  async canGoBack(view) {\n    return this.canGoBackSync(view);\n  }\n  /**\n   * Get the previous view.\n   *\n   * @param view The view to get.\n   */\n  async getPrevious(view) {\n    return this.getPreviousSync(view);\n  }\n  getLength() {\n    return this.views.length;\n  }\n  getActiveSync() {\n    return this.views[this.views.length - 1];\n  }\n  canGoBackSync(view = this.getActiveSync()) {\n    return !!(view && this.getPreviousSync(view));\n  }\n  getPreviousSync(view = this.getActiveSync()) {\n    if (!view) {\n      return undefined;\n    }\n    const views = this.views;\n    const index = views.indexOf(view);\n    return index > 0 ? views[index - 1] : undefined;\n  }\n  /**\n   * Adds a navigation stack change to the queue and schedules it to run.\n   *\n   * @returns Whether the transition succeeds.\n   */\n  async queueTrns(ti, done) {\n    var _a, _b;\n    if (this.isTransitioning && ((_a = ti.opts) === null || _a === void 0 ? void 0 : _a.skipIfBusy)) {\n      return false;\n    }\n    const promise = new Promise((resolve, reject) => {\n      ti.resolve = resolve;\n      ti.reject = reject;\n    });\n    ti.done = done;\n    /**\n     * If using router, check to see if navigation hooks\n     * will allow us to perform this transition. This\n     * is required in order for hooks to work with\n     * the ion-back-button or swipe to go back.\n     */\n    if (ti.opts && ti.opts.updateURL !== false && this.useRouter) {\n      const router = document.querySelector('ion-router');\n      if (router) {\n        const canTransition = await router.canTransition();\n        if (canTransition === false) {\n          return false;\n        }\n        if (typeof canTransition === 'string') {\n          router.push(canTransition, ti.opts.direction || 'back');\n          return false;\n        }\n      }\n    }\n    // Normalize empty\n    if (((_b = ti.insertViews) === null || _b === void 0 ? void 0 : _b.length) === 0) {\n      ti.insertViews = undefined;\n    }\n    // Enqueue transition instruction\n    this.transInstr.push(ti);\n    // if there isn't a transition already happening\n    // then this will kick off this transition\n    this.nextTrns();\n    return promise;\n  }\n  success(result, ti) {\n    if (this.destroyed) {\n      this.fireError('nav controller was destroyed', ti);\n      return;\n    }\n    if (ti.done) {\n      ti.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);\n    }\n    ti.resolve(result.hasCompleted);\n    if (ti.opts.updateURL !== false && this.useRouter) {\n      const router = document.querySelector('ion-router');\n      if (router) {\n        const direction = result.direction === 'back' ? 'back' : 'forward';\n        router.navChanged(direction);\n      }\n    }\n  }\n  failed(rejectReason, ti) {\n    if (this.destroyed) {\n      this.fireError('nav controller was destroyed', ti);\n      return;\n    }\n    this.transInstr.length = 0;\n    this.fireError(rejectReason, ti);\n  }\n  fireError(rejectReason, ti) {\n    if (ti.done) {\n      ti.done(false, false, rejectReason);\n    }\n    if (ti.reject && !this.destroyed) {\n      ti.reject(rejectReason);\n    }\n    else {\n      ti.resolve(false);\n    }\n  }\n  /**\n   * Consumes the next transition in the queue.\n   *\n   * @returns whether the transition is executed.\n   */\n  nextTrns() {\n    // this is the framework's bread 'n butta function\n    // only one transition is allowed at any given time\n    if (this.isTransitioning) {\n      return false;\n    }\n    // there is no transition happening right now, executes the next instructions.\n    const ti = this.transInstr.shift();\n    if (!ti) {\n      return false;\n    }\n    this.runTransition(ti);\n    return true;\n  }\n  /** Executes all the transition instruction from the queue. */\n  async runTransition(ti) {\n    try {\n      // set that this nav is actively transitioning\n      this.ionNavWillChange.emit();\n      this.isTransitioning = true;\n      this.prepareTI(ti);\n      const leavingView = this.getActiveSync();\n      const enteringView = this.getEnteringView(ti, leavingView);\n      if (!leavingView && !enteringView) {\n        throw new Error('no views in the stack to be removed');\n      }\n      if (enteringView && enteringView.state === VIEW_STATE_NEW) {\n        await enteringView.init(this.el);\n      }\n      this.postViewInit(enteringView, leavingView, ti);\n      // Needs transition?\n      const requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) && enteringView !== leavingView;\n      if (requiresTransition && ti.opts && leavingView) {\n        const isBackDirection = ti.opts.direction === 'back';\n        /**\n         * If heading back, use the entering page's animation\n         * unless otherwise specified by the developer.\n         */\n        if (isBackDirection) {\n          ti.opts.animationBuilder = ti.opts.animationBuilder || (enteringView === null || enteringView === void 0 ? void 0 : enteringView.animationBuilder);\n        }\n        leavingView.animationBuilder = ti.opts.animationBuilder;\n      }\n      let result;\n      if (requiresTransition) {\n        result = await this.transition(enteringView, leavingView, ti);\n      }\n      else {\n        // transition is not required, so we are already done!\n        // they're inserting/removing the views somewhere in the middle or\n        // beginning, so visually nothing needs to animate/transition\n        // resolve immediately because there's no animation that's happening\n        result = {\n          hasCompleted: true,\n          requiresTransition: false,\n        };\n      }\n      this.success(result, ti);\n      this.ionNavDidChange.emit();\n    }\n    catch (rejectReason) {\n      this.failed(rejectReason, ti);\n    }\n    this.isTransitioning = false;\n    this.nextTrns();\n  }\n  prepareTI(ti) {\n    var _a, _b;\n    var _c;\n    const viewsLength = this.views.length;\n    (_a = ti.opts) !== null && _a !== void 0 ? _a : (ti.opts = {});\n    (_b = (_c = ti.opts).delegate) !== null && _b !== void 0 ? _b : (_c.delegate = this.delegate);\n    if (ti.removeView !== undefined) {\n      assert(ti.removeStart !== undefined, 'removeView needs removeStart');\n      assert(ti.removeCount !== undefined, 'removeView needs removeCount');\n      const index = this.views.indexOf(ti.removeView);\n      if (index < 0) {\n        throw new Error('removeView was not found');\n      }\n      ti.removeStart += index;\n    }\n    if (ti.removeStart !== undefined) {\n      if (ti.removeStart < 0) {\n        ti.removeStart = viewsLength - 1;\n      }\n      if (ti.removeCount < 0) {\n        ti.removeCount = viewsLength - ti.removeStart;\n      }\n      ti.leavingRequiresTransition = ti.removeCount > 0 && ti.removeStart + ti.removeCount === viewsLength;\n    }\n    if (ti.insertViews) {\n      // allow -1 to be passed in to auto push it on the end\n      // and clean up the index if it's larger then the size of the stack\n      if (ti.insertStart < 0 || ti.insertStart > viewsLength) {\n        ti.insertStart = viewsLength;\n      }\n      ti.enteringRequiresTransition = ti.insertStart === viewsLength;\n    }\n    const insertViews = ti.insertViews;\n    if (!insertViews) {\n      return;\n    }\n    assert(insertViews.length > 0, 'length can not be zero');\n    const viewControllers = convertToViews(insertViews);\n    if (viewControllers.length === 0) {\n      throw new Error('invalid views to insert');\n    }\n    // Check all the inserted view are correct\n    for (const view of viewControllers) {\n      view.delegate = ti.opts.delegate;\n      const nav = view.nav;\n      if (nav && nav !== this) {\n        throw new Error('inserted view was already inserted');\n      }\n      if (view.state === VIEW_STATE_DESTROYED) {\n        throw new Error('inserted view was already destroyed');\n      }\n    }\n    ti.insertViews = viewControllers;\n  }\n  /**\n   * Returns the view that will be entered considering the transition instructions.\n   *\n   * @param ti The instructions.\n   * @param leavingView The view being left or undefined if none.\n   *\n   * @returns The view that will be entered, undefined if none.\n   */\n  getEnteringView(ti, leavingView) {\n    // The last inserted view will be entered when view are inserted.\n    const insertViews = ti.insertViews;\n    if (insertViews !== undefined) {\n      return insertViews[insertViews.length - 1];\n    }\n    // When views are deleted, we will enter the last view that is not removed and not the view being left.\n    const removeStart = ti.removeStart;\n    if (removeStart !== undefined) {\n      const views = this.views;\n      const removeEnd = removeStart + ti.removeCount;\n      for (let i = views.length - 1; i >= 0; i--) {\n        const view = views[i];\n        if ((i < removeStart || i >= removeEnd) && view !== leavingView) {\n          return view;\n        }\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Adds and Removes the views from the navigation stack.\n   *\n   * @param enteringView The view being entered.\n   * @param leavingView The view being left.\n   * @param ti The instructions.\n   */\n  postViewInit(enteringView, leavingView, ti) {\n    var _a, _b, _c;\n    assert(leavingView || enteringView, 'Both leavingView and enteringView are null');\n    assert(ti.resolve, 'resolve must be valid');\n    assert(ti.reject, 'reject must be valid');\n    // Compute the views to remove.\n    const opts = ti.opts;\n    const { insertViews, removeStart, removeCount } = ti;\n    /** Records the view to destroy */\n    let destroyQueue;\n    // there are views to remove\n    if (removeStart !== undefined && removeCount !== undefined) {\n      assert(removeStart >= 0, 'removeStart can not be negative');\n      assert(removeCount >= 0, 'removeCount can not be negative');\n      destroyQueue = [];\n      for (let i = removeStart; i < removeStart + removeCount; i++) {\n        const view = this.views[i];\n        if (view !== undefined && view !== enteringView && view !== leavingView) {\n          destroyQueue.push(view);\n        }\n      }\n      // default the direction to \"back\"\n      (_a = opts.direction) !== null && _a !== void 0 ? _a : (opts.direction = 'back');\n    }\n    const finalNumViews = this.views.length + ((_b = insertViews === null || insertViews === void 0 ? void 0 : insertViews.length) !== null && _b !== void 0 ? _b : 0) - (removeCount !== null && removeCount !== void 0 ? removeCount : 0);\n    assert(finalNumViews >= 0, 'final balance can not be negative');\n    if (finalNumViews === 0) {\n      console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.el);\n      throw new Error('navigation stack needs at least one root page');\n    }\n    // At this point the transition can not be rejected, any throw should be an error\n    // Insert the new views in the stack.\n    if (insertViews) {\n      // add the views to the\n      let insertIndex = ti.insertStart;\n      for (const view of insertViews) {\n        this.insertViewAt(view, insertIndex);\n        insertIndex++;\n      }\n      if (ti.enteringRequiresTransition) {\n        // default to forward if not already set\n        (_c = opts.direction) !== null && _c !== void 0 ? _c : (opts.direction = 'forward');\n      }\n    }\n    // if the views to be removed are in the beginning or middle\n    // and there is not a view that needs to visually transition out\n    // then just destroy them and don't transition anything\n    // batch all of lifecycles together\n    // let's make sure, callbacks are zoned\n    if (destroyQueue && destroyQueue.length > 0) {\n      for (const view of destroyQueue) {\n        lifecycle(view.element, LIFECYCLE_WILL_LEAVE);\n        lifecycle(view.element, LIFECYCLE_DID_LEAVE);\n        lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);\n      }\n      // once all lifecycle events has been delivered, we can safely detroy the views\n      for (const view of destroyQueue) {\n        this.destroyView(view);\n      }\n    }\n  }\n  async transition(enteringView, leavingView, ti) {\n    // we should animate (duration > 0) if the pushed page is not the first one (startup)\n    // or if it is a portal (modal, actionsheet, etc.)\n    const opts = ti.opts;\n    const progressCallback = opts.progressAnimation\n      ? (ani) => {\n        /**\n         * Because this progress callback is called asynchronously\n         * it is possible for the gesture to start and end before\n         * the animation is ever set. In that scenario, we should\n         * immediately call progressEnd so that the transition promise\n         * resolves and the gesture does not get locked up.\n         */\n        if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n          this.gestureOrAnimationInProgress = true;\n          ani.onFinish(() => {\n            this.gestureOrAnimationInProgress = false;\n          }, { oneTimeCallback: true });\n          /**\n           * Playing animation to beginning\n           * with a duration of 0 prevents\n           * any flickering when the animation\n           * is later cleaned up.\n           */\n          ani.progressEnd(0, 0, 0);\n        }\n        else {\n          this.sbAni = ani;\n        }\n      }\n      : undefined;\n    const mode = getIonMode(this);\n    const enteringEl = enteringView.element;\n    const leavingEl = leavingView && leavingView.element;\n    const animationOpts = Object.assign(Object.assign({ mode, showGoBack: this.canGoBackSync(enteringView), baseEl: this.el, progressCallback, animated: this.animated && config.getBoolean('animated', true), enteringEl,\n      leavingEl }, opts), { animationBuilder: opts.animationBuilder || this.animation || config.get('navAnimation') });\n    const { hasCompleted } = await transition(animationOpts);\n    return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);\n  }\n  transitionFinish(hasCompleted, enteringView, leavingView, opts) {\n    /**\n     * If the transition did not complete, the leavingView will still be the active\n     * view on the stack. Otherwise unmount all the views after the enteringView.\n     */\n    const activeView = hasCompleted ? enteringView : leavingView;\n    if (activeView) {\n      this.unmountInactiveViews(activeView);\n    }\n    return {\n      hasCompleted,\n      requiresTransition: true,\n      enteringView,\n      leavingView,\n      direction: opts.direction,\n    };\n  }\n  /**\n   * Inserts a view at the specified index.\n   *\n   * When the view already is in the stack it will be moved to the new position.\n   *\n   * @param view The view to insert.\n   * @param index The index where to insert the view.\n   */\n  insertViewAt(view, index) {\n    const views = this.views;\n    const existingIndex = views.indexOf(view);\n    if (existingIndex > -1) {\n      assert(view.nav === this, 'view is not part of the nav');\n      // The view already in the stack, removes it.\n      views.splice(existingIndex, 1);\n      // and add it back at the requested index.\n      views.splice(index, 0, view);\n    }\n    else {\n      assert(!view.nav, 'nav is used');\n      // this is a new view to add to the stack\n      // create the new entering view\n      view.nav = this;\n      views.splice(index, 0, view);\n    }\n  }\n  /**\n   * Removes a view from the stack.\n   *\n   * @param view The view to remove.\n   */\n  removeView(view) {\n    assert(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, 'view state should be loaded or destroyed');\n    const views = this.views;\n    const index = views.indexOf(view);\n    assert(index > -1, 'view must be part of the stack');\n    if (index >= 0) {\n      views.splice(index, 1);\n    }\n  }\n  destroyView(view) {\n    view._destroy();\n    this.removeView(view);\n  }\n  /**\n   * Unmounts all inactive views after the specified active view.\n   *\n   * DOM WRITE\n   *\n   * @param activeView The view that is actively visible in the stack. Used to calculate which views to unmount.\n   */\n  unmountInactiveViews(activeView) {\n    // ok, cleanup time!! Destroy all of the views that are\n    // INACTIVE and come after the active view\n    // only do this if the views exist, though\n    if (this.destroyed) {\n      return;\n    }\n    const views = this.views;\n    const activeViewIndex = views.indexOf(activeView);\n    for (let i = views.length - 1; i >= 0; i--) {\n      const view = views[i];\n      /**\n       * When inserting multiple views via insertPages\n       * the last page will be transitioned to, but the\n       * others will not be. As a result, a DOM element\n       * will only be created for the last page inserted.\n       * As a result, it is possible to have views in the\n       * stack that do not have `view.element` yet.\n       */\n      const element = view.element;\n      if (element) {\n        if (i > activeViewIndex) {\n          // this view comes after the active view\n          // let's unload it\n          lifecycle(element, LIFECYCLE_WILL_UNLOAD);\n          this.destroyView(view);\n        }\n        else if (i < activeViewIndex) {\n          // this view comes before the active view\n          // and it is not a portal then ensure it is hidden\n          setPageHidden(element, true);\n        }\n      }\n    }\n  }\n  canStart() {\n    return (!this.gestureOrAnimationInProgress &&\n      !!this.swipeGesture &&\n      !this.isTransitioning &&\n      this.transInstr.length === 0 &&\n      this.canGoBackSync());\n  }\n  onStart() {\n    this.gestureOrAnimationInProgress = true;\n    this.pop({ direction: 'back', progressAnimation: true });\n  }\n  onMove(stepValue) {\n    if (this.sbAni) {\n      this.sbAni.progressStep(stepValue);\n    }\n  }\n  onEnd(shouldComplete, stepValue, dur) {\n    if (this.sbAni) {\n      this.sbAni.onFinish(() => {\n        this.gestureOrAnimationInProgress = false;\n      }, { oneTimeCallback: true });\n      // Account for rounding errors in JS\n      let newStepValue = shouldComplete ? -0.001 : 0.001;\n      /**\n       * Animation will be reversed here, so need to\n       * reverse the easing curve as well\n       *\n       * Additionally, we need to account for the time relative\n       * to the new easing curve, as `stepValue` is going to be given\n       * in terms of a linear curve.\n       */\n      if (!shouldComplete) {\n        this.sbAni.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n        newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];\n      }\n      else {\n        newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];\n      }\n      this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n    }\n    else {\n      this.gestureOrAnimationInProgress = false;\n    }\n  }\n  render() {\n    return h(\"slot\", null);\n  }\n  static get is() { return \"ion-nav\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"nav.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"nav.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"delegate\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"FrameworkDelegate\",\n          \"resolved\": \"FrameworkDelegate | undefined\",\n          \"references\": {\n            \"FrameworkDelegate\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        }\n      },\n      \"swipeGesture\": {\n        \"type\": \"boolean\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If the nav component should allow for swipe-to-go-back.\"\n        },\n        \"attribute\": \"swipe-gesture\",\n        \"reflect\": false\n      },\n      \"animated\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the nav should animate the transition of components.\"\n        },\n        \"attribute\": \"animated\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"animation\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"AnimationBuilder\",\n          \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n          \"references\": {\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"By default `ion-nav` animates transition between pages based in the mode (ios or material design).\\nHowever, this property allows to create custom transition using `AnimationBuilder` functions.\"\n        }\n      },\n      \"rootParams\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"ComponentProps\",\n          \"resolved\": \"undefined | { [key: string]: any; }\",\n          \"references\": {\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Any parameters for the root component\"\n        }\n      },\n      \"root\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"NavComponent\",\n          \"resolved\": \"Function | HTMLElement | ViewController | null | string | undefined\",\n          \"references\": {\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Root NavComponent to load\"\n        },\n        \"attribute\": \"root\",\n        \"reflect\": false\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionNavWillLoad\",\n        \"name\": \"ionNavWillLoad\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"Event fired when Nav will load a component\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionNavWillChange\",\n        \"name\": \"ionNavWillChange\",\n        \"bubbles\": false,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Event fired when the nav will change components\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionNavDidChange\",\n        \"name\": \"ionNavDidChange\",\n        \"bubbles\": false,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Event fired when the nav has changed components\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"push\": {\n        \"complexType\": {\n          \"signature\": \"<T extends NavComponent>(component: T, componentProps?: ComponentProps<T> | null, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"component The component to push onto the navigation stack.\"\n                }],\n              \"text\": \"The component to push onto the navigation stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"componentProps Any properties of the component.\"\n                }],\n              \"text\": \"Any properties of the component.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"T\": {\n              \"location\": \"global\"\n            },\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Push a new component onto the current navigation stack. Pass any additional\\ninformation along as an object. This additional information is accessible\\nthrough NavParams.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"component The component to push onto the navigation stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"componentProps Any properties of the component.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"insert\": {\n        \"complexType\": {\n          \"signature\": \"<T extends NavComponent>(insertIndex: number, component: T, componentProps?: ComponentProps<T> | null, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"insertIndex The index to insert the component at in the stack.\"\n                }],\n              \"text\": \"The index to insert the component at in the stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"component The component to insert into the navigation stack.\"\n                }],\n              \"text\": \"The component to insert into the navigation stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"componentProps Any properties of the component.\"\n                }],\n              \"text\": \"Any properties of the component.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"T\": {\n              \"location\": \"global\"\n            },\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Inserts a component into the navigation stack at the specified index.\\nThis is useful to add a component at any point in the navigation stack.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"insertIndex The index to insert the component at in the stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"component The component to insert into the navigation stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"componentProps Any properties of the component.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"insertPages\": {\n        \"complexType\": {\n          \"signature\": \"(insertIndex: number, insertComponents: NavComponent[] | NavComponentWithProps[], opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"insertIndex The index to insert the components at in the stack.\"\n                }],\n              \"text\": \"The index to insert the components at in the stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"insertComponents The components to insert into the navigation stack.\"\n                }],\n              \"text\": \"The components to insert into the navigation stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"NavComponentWithProps\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Inserts an array of components into the navigation stack at the specified index.\\nThe last component in the array will become instantiated as a view, and animate\\nin to become the active view.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"insertIndex The index to insert the components at in the stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"insertComponents The components to insert into the navigation stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"pop\": {\n        \"complexType\": {\n          \"signature\": \"(opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Pop a component off of the navigation stack. Navigates back from the current\\ncomponent.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"popTo\": {\n        \"complexType\": {\n          \"signature\": \"(indexOrViewCtrl: number | ViewController, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"indexOrViewCtrl The index or view controller to pop to.\"\n                }],\n              \"text\": \"The index or view controller to pop to.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ViewController\": {\n              \"location\": \"import\",\n              \"path\": \"./view-controller\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionInstruction\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Pop to a specific index in the navigation stack.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"indexOrViewCtrl The index or view controller to pop to.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"popToRoot\": {\n        \"complexType\": {\n          \"signature\": \"(opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Navigate back to the root of the stack, no matter how far back that is.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"removeIndex\": {\n        \"complexType\": {\n          \"signature\": \"(startIndex: number, removeCount?: number, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"startIndex The number to begin removal at.\"\n                }],\n              \"text\": \"The number to begin removal at.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"removeCount The number of components to remove.\"\n                }],\n              \"text\": \"The number of components to remove.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Removes a component from the navigation stack at the specified index.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"startIndex The number to begin removal at.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"removeCount The number of components to remove.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"setRoot\": {\n        \"complexType\": {\n          \"signature\": \"<T extends NavComponent>(component: T, componentProps?: ComponentProps<T> | null, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"component The component to set as the root of the navigation stack.\"\n                }],\n              \"text\": \"The component to set as the root of the navigation stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"componentProps Any properties of the component.\"\n                }],\n              \"text\": \"Any properties of the component.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"T\": {\n              \"location\": \"global\"\n            },\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Set the root for the current navigation stack to a component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"component The component to set as the root of the navigation stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"componentProps Any properties of the component.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"setPages\": {\n        \"complexType\": {\n          \"signature\": \"(views: NavComponent[] | NavComponentWithProps[], opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"views The list of views to set as the navigation stack.\"\n                }],\n              \"text\": \"The list of views to set as the navigation stack.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"opts The navigation options.\"\n                }],\n              \"text\": \"The navigation options.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"done The transition complete function.\"\n                }],\n              \"text\": \"The transition complete function.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"NavComponent\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"NavComponentWithProps\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            },\n            \"TransitionDoneFn\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Set the views of the current navigation stack and navigate to the last view.\\nBy default animations are disabled, but they can be enabled by passing options\\nto the navigation controller. Navigation parameters can also be passed to the\\nindividual pages in the array.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"views The list of views to set as the navigation stack.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"opts The navigation options.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"done The transition complete function.\"\n            }]\n        }\n      },\n      \"setRouteId\": {\n        \"complexType\": {\n          \"signature\": \"(id: string, params: ComponentProps | undefined, direction: RouterDirection, animation?: AnimationBuilder) => Promise<RouteWrite>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"id The component tag.\"\n                }],\n              \"text\": \"The component tag.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"params The component params.\"\n                }],\n              \"text\": \"The component params.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"direction A direction hint.\"\n                }],\n              \"text\": \"A direction hint.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"animation an AnimationBuilder.\"\n                }],\n              \"text\": \"an AnimationBuilder.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouteWrite\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            },\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"RouterDirection\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            },\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"NavOptions\": {\n              \"location\": \"import\",\n              \"path\": \"./nav-interface\"\n            }\n          },\n          \"return\": \"Promise<RouteWrite>\"\n        },\n        \"docs\": {\n          \"text\": \"Called by the router to update the view.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"id The component tag.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"params The component params.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"direction A direction hint.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"animation an AnimationBuilder.\"\n            }, {\n              \"name\": \"return\",\n              \"text\": \"the status.\"\n            }, {\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"getRouteId\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<RouteID | undefined>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"RouteID\": {\n              \"location\": \"import\",\n              \"path\": \"../router/utils/interface\"\n            }\n          },\n          \"return\": \"Promise<RouteID | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"Called by <ion-router> to retrieve the current component.\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"getActive\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<ViewController | undefined>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ViewController\": {\n              \"location\": \"import\",\n              \"path\": \"./view-controller\"\n            }\n          },\n          \"return\": \"Promise<ViewController | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"Get the active view.\",\n          \"tags\": []\n        }\n      },\n      \"getByIndex\": {\n        \"complexType\": {\n          \"signature\": \"(index: number) => Promise<ViewController | undefined>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"index The index of the view.\"\n                }],\n              \"text\": \"The index of the view.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ViewController\": {\n              \"location\": \"import\",\n              \"path\": \"./view-controller\"\n            }\n          },\n          \"return\": \"Promise<ViewController | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"Get the view at the specified index.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"index The index of the view.\"\n            }]\n        }\n      },\n      \"canGoBack\": {\n        \"complexType\": {\n          \"signature\": \"(view?: ViewController) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"view The view to check.\"\n                }],\n              \"text\": \"The view to check.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ViewController\": {\n              \"location\": \"import\",\n              \"path\": \"./view-controller\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns `true` if the current view can go back.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"view The view to check.\"\n            }]\n        }\n      },\n      \"getPrevious\": {\n        \"complexType\": {\n          \"signature\": \"(view?: ViewController) => Promise<ViewController | undefined>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"view The view to get.\"\n                }],\n              \"text\": \"The view to get.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ViewController\": {\n              \"location\": \"import\",\n              \"path\": \"./view-controller\"\n            }\n          },\n          \"return\": \"Promise<ViewController | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"Get the previous view.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"view The view to get.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"swipeGesture\",\n        \"methodName\": \"swipeGestureChanged\"\n      }, {\n        \"propName\": \"root\",\n        \"methodName\": \"rootChanged\"\n      }];\n  }\n}\n"],"mappings":"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"}